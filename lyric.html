<!--

OKAY.

This is going to be like Steno Hero, but BETTER.

The primary innovations are:

1. Different difficulty levels.  You have to be PRETTY good at
steno to do song data, which means newbies are missing out on
the fun.  One way to solve this problem is to SIMPLIFY what you
actually have to stroke out.  We'll have these modes:

    Vowels only: stroke out the vowels of words.  We can either
    be single vowel (in which case ANY vowel in the word is
    accepted) or multi-vowel (you have to give the vowels for
    ALL of the strokes of a given spelling).

    Starting consonants: stroke out the initial consonant of a word.

    Terminal consonants: stroke out the terminal consonant

    Left hand/right hand mode: basically, you only need to stroke
    one hand's worth (well, do the vowel keys for the other hand.)

    Full mode

Additionally, you can toggle whether or not solitary briefs should
be included in this stream; also, you can do JUST briefs.

Give bonus points for streaks

Stats gathering, render it with D3

Lots of code shamelessly ripped off from QWERTY Steno.

UI Notes:

1. What should happen when we move onto the next cue?  Some data
files may switch to the next lyric early in order to accommodate the
karaoke use-case, but we want to give a stenographer some grace period
before moving on.  Idea: when the cue file indicates the next cue is
due, but the stenographer hasn't gotten there yet, give them a little
grace period proportional to the length of the next phrase.  If their
percent completion of the previous lyric isn't good enough, however,
kick them out immediately.

TODO:

1. Partial strokes UI is pretty confusing.  Can we chunk up the
words somehow?  Seems algorithmically tricky.

2. Hook up to LRC and YouTube (YouTube has a nice JS API).

-->
<html>
<link rel="prefetch" href="dict.json">
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<style>
#viewport { font-size: 2em; }
.brief {color: blue;}
.nostroke {color: purple;}
.done {color: grey !important;}
.current {background:#DDD}
.complete {background:#9F9}
#chkPlainTextInput {display: none}
.boxLabel {margin-right:1em;}
h2 {font-size:1.2em;}
td {vertical-align: top;}
</style>
<body>
<div id="viewport"><em>Loading Dictionary...</em></div>
<div>
<input type="text" id="txtInput">
<input type="submit" value="&lt;" id="prevbtn">
<input type="submit" value="&gt;" id="nextbtn">
</div>
<div id="barometer"></div>
<span id="prompt"></span>
<input type="checkbox" id="chkPlainTextInput">
<hr>
<p>
How to use me: copy paste some exercise material (for example, the exercises in <a href="https://sites.google.com/site/ploverdoc/lesson-1-fingers-and-keys">Learn Plover</a>) and select what kind of exercise you want to do.
</p>
<h2>Mode:</h2>
<table id="modebtns">
    <tr>
        <td><input type="radio" name="mode" value="accuracy" onclick="updateMode()" checked></td>
        <td><strong class="boxLabel">Accuracy</strong> If you misstroke, the stroke is rejected; you cannot move on until you get the stroke right.</td>
    </tr>
    <tr>
        <td><input type="radio" name="mode" value="speed" onclick="updateMode()" disabled></td>
        <td><strong class="boxLabel">Speed</strong> If you misstroke a word, you'll move onto the next one.  (Not implemented)</td>
    </tr>
</table>
<h2>Style:</h2>
<table id="stylebtns">
    <tr>
        <td><input type="radio" name="style" value="script" checked></td>
        <td><strong class="boxLabel">Script</strong> Follow the script in the source order.</td>
    </tr>
    <tr>
        <td><input type="radio" name="style" value="randomized"></td>
        <td><strong class="boxLabel">Randomized</strong> Generate <input type="text" id="randomLength" value="100" size="1"> random words sampled from the source input (weighted based on occurrence frequency).</td>
    </tr>
</table>
<h2>Difficulty:</h2>
<table id="difficultybtns">
    <tr>
        <td><input type="radio" name="difficulty" value="vowel" checked></td>
        <td><strong class="boxLabel">Vowels only</strong> You only need to stroke
            the AOEU keys of any word to be stroked.  Solitary briefs
            (which aren't spelled phonetically) are omitted.
        </td>
    </tr>
    <tr>
        <td><input type="radio" name="difficulty" value="leftvowel"></td>
        <td><strong class="boxLabel">Left hand</strong> You only need to stroke
            the left hand keys and all vowels.
        </td>
    </tr>
    <tr>
        <td><input type="radio" name="difficulty" value="rightvowel"></td>
        <td><strong class="boxLabel">Right hand</strong> You only need to stroke
            the right hand keys and all vowels.  This difficulty mode may not make much
            sense on exercises with multi-stroke words.
        </td>
    </tr>
    <tr>
        <td><input type="radio" name="difficulty" value="standard"></td>
        <td><strong class="boxLabel">Case-insensitive, no punctuation</strong>
            Stroke your way to victory.
        </td>
    </tr>
</table>
<input type="submit" value="Clear" id="clearbtn">
<input type="submit" value="Load" id="loadbtn">
        <div><textarea id="data" cols="80" rows="20">
The quick brown fox jumps over the lazy dog.
Pack my box with five dozen liquor jugs.
</textarea></div>
<script>
// ----------------------------------------------------------------------------
// Dictionary initialization
var rdata = {"i": ["EU"]};
$.getJSON("dict.json", function(dict) {
        $.each( dict, function(k,rv) {
            if (/\d/.test(k)) return;
            var v = rv.toLowerCase();
            if (rdata.hasOwnProperty(v)) { // watch
                rdata[v].push(k);
            } else {
                rdata[v] = [k];
            }
            });
        init();
        });

function depunctuateWord(rword) {
    return rword.replace(/[!"#$%&\\\(\)*+,-.\/:;<=>?@\[\]\^_`{|}~]/g, "").replace(/^'/, "").replace(/'$/, "");
}
function cleanWord(rword) {
    return depunctuateWord(rword).toLowerCase();
}
function wordStrokes(word) {
    var r = rdata[cleanWord(word)];
    return r ? r : [];
}
function vowelifyStroke(stroke) {
    var r = [];
    var parts = stroke.split('/');
    for (var i = 0; i < parts.length; i++) {
        var m = parts[i].match(/[AOEU]+/);
        if (m && parts[i].indexOf("*") == -1) {
            r.push(m[0]);
        } else {
            return false;
        }
    }
    return r.join('/');
}
function leftifyStroke(stroke) {
    var steno = stroke.split('/')[0];
    var left = getLeftLettersFromSteno(steno);
    return left;
}
function rightifyStroke(stroke) {
    var steno = stroke.split('/')[0];
    var right = getRightLettersFromSteno(steno);
    return right;
}
function leftifyVowelStroke(stroke) {
    var steno = stroke.split('/')[0];
    var left = getLeftLettersFromSteno(steno);
    var middle = getMiddleLettersFromSteno(steno);
    return left + middle;
}
function rightifyVowelStroke(stroke) {
    var steno = stroke.split('/')[0];
    var middle = getMiddleLettersFromSteno(steno);
    var right = getRightLettersFromSteno(steno);
    return middle + right;
}
function bestStroke(strokes) {
    var cand;
    $.each(strokes, function(i, s) {
            cand = take_best(cand, s);
            });
    return cand;
}
function solitaryBrief(word) {
    if (cleanWord(word) == "it's") return true;
    return wordStrokes(word).every(function(s) {return vowelifyStroke(s) == s && !s.match(/^[AOEU\/]+$/)});
}
// TODO: lift "chordifying" code from https://plover.goeswhere.com/
// so we can get per-chord stats

// ----------------------------------------------------------------------------
// Main user interface
var data, cur_line, cur_word;
var cur_elems;
var currentStroke = 1;
var cur_mode, cur_difficulty, cur_style;
var cur_difficulty_transform;
var samples; // {time: Date, start_time: Date, expected_strokes: [String], actual_stroke: String, line: Number, word: Number}
var stroke_start, exercise_start;
var streak = 0;
var best_streak = 0;

function updateMode() {
    cur_mode = $('input[name=mode]:checked', '#modebtns').val();
}

function updateDifficulty() {
    cur_difficulty = $('input[name=difficulty]:checked', '#difficultybtns').val();
    if (cur_difficulty == "vowel") {
        cur_difficulty_transform = vowelifyStroke;
    } else if (cur_difficulty == "left") {
        cur_difficulty_transform = leftifyStroke;
    } else if (cur_difficulty == "right") {
        cur_difficulty_transform = rightifyStroke;
    } else if (cur_difficulty == "leftvowel") {
        cur_difficulty_transform = leftifyVowelStroke;
    } else if (cur_difficulty == "rightvowel") {
        cur_difficulty_transform = rightifyVowelStroke;
    } else {
        cur_difficulty_transform = function(s) {return s;}
    }
}

function updateStyle() {
    cur_style = $('input[name=style]:checked', '#stylebtns').val();
}

function updateBarometer() {
    if (!exercise_start) {
        exercise_start = new Date();
    }
    var wpm = Math.round((1000 * 60 * (data[cur_line].index + cur_word)) / ((new Date()).getTime() - exercise_start.getTime()));
    if (wpm > 300) { wpm = 300; }
    // ToDo: WPM is not really right, but doing it this way
    // so that the easier difficulty modes are not completely
    // bogus
    $('#barometer').html(cur_line + "/" + data.length + " <strong>WPM:</strong> " + wpm + ", <strong>Streak:</strong> " + streak + " (best: " + best_streak + ")");
}

// hmm, I don't know what to actually do with this data
function addSample(actual, expecteds) {
    /*
    samples.push({time: new Date(),
                  start_time: stroke_start,
                  actual_stroke: actual,
                  expected_strokes: expecteds,
                  line: cur_line,
                  word: cur_word});
                  */
    updateBarometer();
}

function init() {
    $("#txtInput").val(""); // force empty
    $("#loadbtn").click(loadData);
    $("#clearbtn").click(function() {$("#data").val("")});
    $("#txtInput").keyup(keyUp).keydown(keyDown);
    $("#prevbtn").click(function() {
            if (cur_line == 0) {
                cur_word = -1;
                paintLine();
                return;
            }
            var i = 1;
            var old_cur_line = cur_line;
            while (cur_line >= old_cur_line && cur_line - i >= 0) {
                cur_line -= i;
                cur_word = -1;
                paintLine();
                i++;
            }
        });
    $("#nextbtn").click(function() {
        if (cur_line == data.length - 1) return;
        cur_line++;
        cur_word = -1;
        paintLine();
        });
    loadData();
    updateMode();
}
function loadData() {
    data = [];
    var text = $("#data").val();
    var lines = text.split("\n");
    var c = 0;
    updateStyle();
    updateDifficulty();
    if (cur_style == "script") {
        $.each( lines, function(i,line) {
                var cur = [];
                var sub_c = 0;
                var words = line.split(" ");
                $.each( words, function(i,word) {
                    if (/\S/.test(word)) {
                        cur.push(word);
                        if (mapFilter(wordStrokes(word), cur_difficulty_transform)) {
                            sub_c++;
                        }
                    }
                    });
                if (cur.length > 0) data.push({index: c, words: cur});
                c += sub_c;
                });
    } else {
        var count = parseInt($("#randomLength").val());
        var corpus = [];
        $.each( lines, function(i,line) {
                var words = line.split(" ");
                $.each( words, function(i, rword) {
                    var word = depunctuateWord(rword);
                    if (/\S/.test(word) && mapFilter(wordStrokes(word), cur_difficulty_transform)) {
                        corpus.push(word);
                    }
                    });
                });
        var cur = [];
        for (var i = 0; i < count; i++) {
            if (i % 8 == 0) {
                cur = [];
                data.push({index: i, words: cur});
            }
            cur.push(corpus[Math.floor(Math.random() * corpus.length)]);
        }
    }
    startData();
}
function startData() {
    cur_line = 0;
    cur_word = -1;
    exercise_start = false;
    samples = [];
    streak = 0;
    best_streak = 0;
    $("#txtInput").removeClass("complete");
    paintLine();
}
function paintLine() {
    var v = $("#viewport");
    cur_elems = [];
    v.html('');
    $.each(data[cur_line].words, function (i, word) {
            var elem = $("<span>");
            var strokes = wordStrokes(word);
            if (!strokes.length) {
                elem.addClass("nostroke");
            }
            elem.text(word);
            cur_elems.push(elem);
            v.append(elem);
            v.append(document.createTextNode(" "));
    });
    nextWord();
}
function nextWord() {
    currentStroke = 1;
    answerGivenSoFar = "";
    $("#txtInput").val("");
    $("#prompt").text("");
    if (cur_word >= 0) {
        cur_elems[cur_word].removeClass("current");
        cur_elems[cur_word].removeClass("partial");
        cur_elems[cur_word].addClass("done");
    }
    if (cur_word < data[cur_line].words.length - 1) {
        cur_word++;
    } else if (cur_line < data.length - 1) {
        cur_word = -1;
        cur_line++;
        return paintLine();
    } else {
        // done
        $("#txtInput").addClass("complete");
        return;
    }
    var word = data[cur_line].words[cur_word];
    var strokes = wordStrokes(word);
    var t_strokes = mapFilter(strokes, cur_difficulty_transform);
    if (!t_strokes.length) {
        return nextWord();
    }
    function strokeCompare(a,b) {
        return a.split("/").length - b.split("/").length;
    }
    function mungeStrokes(strokes) {
        return uniq(strokes).sort(strokeCompare).join(",");
    }
    currentDrillItem = {
        "Text": word,
        "Value": mungeStrokes(t_strokes),
    }
    cur_elems[cur_word].addClass("current");
    // TODO: Add other colors which "hint" that the word is funny, e.g. if it is a brief
}

// ----------------------------------------------------------------------------
// Utility functions

function mapFilter(xs, f) {
    return xs.map(f).filter(function(x) {return x});
}

// Given list a of primitive items, returns it with duplicates removed.
function uniq(a) {
    var seen = {};
    return a.filter(function(item) {
        return seen.hasOwnProperty(item) ? false : (seen[item] = true);
    });
}

// Given to steno strokes, picks the 'better' one. We base this
// mostly on stroke size.
function take_best(s1, s2) {
    if (!s1) return s2;
    if (/\d/.test(s1)) { return s2; }
    if (/\d/.test(s2)) { return s1; }
    var l1 = s1.split("/").length;
    var l2 = s2.split("/").length;
    if (l1 < l2) { return s1; }
    else if (l2 < l1) { return s2; }
    // TODO: This doesn't make sense if we're not vowelizing
    if (s1.indexOf('*') == -1 && s2.indexOf('*') != -1) { return s1; }
    if (s2.indexOf('*') == -1 && s1.indexOf('*') != -1) { return s2; }
    if (s1.length < s2.length) { return s1; }
    if (s2.length < s1.length) { return s2; }
    return s1;
}

// ----------------------------------------------------------------------------
// QWERTY Steno support code

// Some of this code is pure, some relies on global state.
// Here are the variable declarations of the global state relied upon:

function showAnswerPrompt(steno) {
    streak = 0;
    var cands = currentDrillItem.
        Value.
        split(",").
        filter(function(v){return v.indexOf(answerGivenSoFar) == 0}).
        map(function(v) {return v.substring(answerGivenSoFar.length)});
    // PROBLEM: want to figure out what LIKELY candidate was
    addSample(steno, cands);
    $("#prompt").text(bestStroke(cands) + ", you did " + steno);
}
function setStenoKeyboardPressedKeys() {}
function clearStenoKeyboardPressed() {}
function hideAnswerPrompt() {}
function showWpm() {}
function setNextDrillItem() {
    streak++;
    if (streak > best_streak) best_streak = streak;
    nextWord();
}
function possibleAnswerClick() {
}
function showDrillItem() {}
// Here is the library code.

var currentTdAnswer = 0;
var itemsAnswered = 0;
var keysUp = [], keysDown = [];
var currentDrillItem;
var answerGivenSoFar = "";
var currentStroke = 1;

function correctAnswer(answer) {
    if (jQuery('#chkPlainTextInput').is(':checked')) {

        // Plain text mode
        var text = currentDrillItem.Text;

        if (text.toLowerCase() == answer.toLowerCase()) {

            return 0;
        }
    }
    else {
        // Steno mode
        var correctAnswersString = currentDrillItem.Value;

        var correctAnswersArray = correctAnswersString.split(",");

        for (var i = 0; i < correctAnswersArray.length; i++) {

            // If this possible answer starts with the same strokes as the user has given
            if (correctAnswersArray[i].indexOf(answerGivenSoFar) == 0) {

                var strokes = correctAnswersArray[i].split("/");

                var correctStroke = strokes[currentStroke - 1];

                if (answer == correctStroke) {

                    // Correct stroke
                    answerGivenSoFar += answer + "/"

                    var strokesRemaining = strokes.length - currentStroke;

                    return strokesRemaining;
                }
            }
        }
    }

    // Not a correct stroke
    return -1;
}

function getMiddleLettersFromSteno(steno) {
    var index = steno.indexOf("-");

    if (index >= 0) {
        // no vowels
        return "";
    }
    var r = "";

    if (steno.indexOf("A") >= 0) {
        r += "A";
    }

    if (steno.indexOf("O") >= 0) {
        r += "O";
    }

    if (steno.indexOf("*") >= 0) {
        r += "*";
    }

    if (steno.indexOf("E") >= 0) {
        r += "E";
    }

    if (steno.indexOf("U") >= 0) {
        r += "U";
    }
    return r;
}

function getLeftLettersFromSteno(steno) {
    
    var index = steno.indexOf("-");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("A");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("O");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("*");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("E");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }
    
    index = steno.indexOf("U");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    return steno;
}

function getRightLettersFromSteno(steno) {
    
    var index = steno.indexOf("-");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("U");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("E");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("*");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("O");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("A");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    return "";
}

function clearKeys() {
    
    keysDown = [];
    keysUp = [];
}

function addKeyDown(letter) {

    if (letter != null) {

        if (jQuery.inArray(letter, keysDown) == -1) {

            keysDown.push(letter);

            setStenoKeyboardPressedKeys(keysDown);
        }
    }
}

function addKeyUp(letter) {

    if (letter != null) {

        if (jQuery.inArray(letter, keysUp) == -1) {

            keysUp.push(letter);
        }
    }
}

function getStenoFromLetterArray(letters) {

    var leftLetters = [];
    var rightLetters = [];
    var middleLetters = [];

    for (var i = 0; i < letters.length; i++) {

        var singleLetter = letters[i];

        var indexOfDash = singleLetter.indexOf("-");

        if (indexOfDash == 0) {

            // Key is on the right
            rightLetters.push(singleLetter[1]);
        }
        else if (indexOfDash == 1) {

            // Key is on the left
            leftLetters.push(singleLetter[0]);
        }
        else if (singleLetter == '#') {

            // Number Bar
            leftLetters.push(singleLetter);
        }
        else {
            // Middle key
            middleLetters.push(singleLetter);
        }
    }

    if (middleLetters.length == 0 && rightLetters.length > 0) {

        middleLetters.push("-");
    }

    var leftString = "";
    var rightString = "";
    var middleString = "";

    leftString = orderLeftStenoLetters(leftLetters);
    rightString = orderRightStenoLetters(rightLetters);
    middleString = orderMiddleStenoLetters(middleLetters);

    return leftString + middleString + rightString;
}

function orderLeftStenoLetters(leftLetters) {

    var result = "";

    result += getLetterFromArray("#", leftLetters);
    result += getLetterFromArray("S", leftLetters);
    result += getLetterFromArray("T", leftLetters);
    result += getLetterFromArray("K", leftLetters);
    result += getLetterFromArray("P", leftLetters);
    result += getLetterFromArray("W", leftLetters);
    result += getLetterFromArray("H", leftLetters);
    result += getLetterFromArray("R", leftLetters);

    return result;
}

function orderRightStenoLetters(rightLetters) {

    var result = "";

    result += getLetterFromArray("F", rightLetters);
    result += getLetterFromArray("R", rightLetters);
    result += getLetterFromArray("P", rightLetters);
    result += getLetterFromArray("B", rightLetters);
    result += getLetterFromArray("L", rightLetters);
    result += getLetterFromArray("G", rightLetters);
    result += getLetterFromArray("T", rightLetters);
    result += getLetterFromArray("S", rightLetters);
    result += getLetterFromArray("D", rightLetters);
    result += getLetterFromArray("Z", rightLetters);

    return result;
}

function orderMiddleStenoLetters(middleLetters) {

    var result = "";

    result += getLetterFromArray("A", middleLetters);
    result += getLetterFromArray("O", middleLetters);
    result += getLetterFromArray("*", middleLetters);
    result += getLetterFromArray("E", middleLetters);
    result += getLetterFromArray("U", middleLetters);
    result += getLetterFromArray("-", middleLetters);

    return result;
}

function getLetterFromArray(singleLetter, letterArray) {

    var result = "";

    if (jQuery.inArray(singleLetter, letterArray) > -1) {

        result += singleLetter;
    }

    return result;
}

function getStenoLetter(keyCode) {

    var result = null;

    if (keyCode == 65 || keyCode == 81) {

        result = "S-";
    }
    else if (keyCode == 87) {

        result = "T-";
    }
    else if (keyCode == 83) {

        result = "K-";
    }
    else if (keyCode == 69) {

        result = "P-";
    }
    else if (keyCode == 68) {

        result = "W-";
    }
    else if (keyCode == 82) {

        result = "H-";
    }
    else if (keyCode == 70) {

        result = "R-";
    }
    else if (keyCode == 84 || keyCode == 89 || keyCode == 71 || keyCode == 72) {

        result = "*";
    }
    else if (keyCode == 67) {

        result = "A";
    }
    else if (keyCode == 86) {

        result = "O";
    }
    else if (keyCode == 78) {

        result = "E";
    }
    else if (keyCode == 77) {

        result = "U";
    }
    else if (keyCode == 85) {

        result = "-F";
    }
    else if (keyCode == 74) {

        result = "-R";
    }
    else if (keyCode == 73) {

        result = "-P";
    }
    else if (keyCode == 75) {

        result = "-B";
    }
    else if (keyCode == 79) {

        result = "-L";
    }
    else if (keyCode == 76) {

        result = "-G";
    }
    else if (keyCode == 80) {

        result = "-T";
    }
    else if (keyCode == 186 || keyCode == 59) {

        result = "-S";
    }
    else if (keyCode == 219) {

        result = "-D";
    }
    else if (keyCode == 192 || keyCode == 222) {

        result = "-Z";
    }
    else if (keyCode >= 48 && keyCode <= 57) {

        result = "#";
    }
    else if (keyCode == 189) {

        result = "#";
    }

    return result;
}

function keyDown(event) {

    if (jQuery('#chkPlainTextInput').is(':checked')) {
        
        // Plain text mode
    }
    else {
        // Steno mode
        event.preventDefault();

        addKeyDown(getStenoLetter(event.keyCode));
    }
}

function keyUp(event) {

    if (jQuery('#chkPlainTextInput').is(':checked')) {

        // Plain text mode
        var text = jQuery('#txtInput').val();

        text = jQuery.trim(text);

        var remainingStrokes = correctAnswer(text);

        if (remainingStrokes == 0) {

            // Correct
            // Entire answer complete, no more remaining strokes
            itemsAnswered++;

            hideAnswerPrompt();

            showWpm();

            setNextDrillItem();

            showDrillItem();

            jQuery('#txtInput').val('');
        }
    }
    else {
        event.preventDefault();

        addKeyUp(getStenoLetter(event.keyCode));

        if (keysUp.length == keysDown.length) {

            // All keys up
            clearStenoKeyboardPressed();

            var steno = getStenoFromLetterArray(keysDown);

            if (steno != "") {

                if (steno != "*") {

                    var remainingStrokes = correctAnswer(steno);

                    if (remainingStrokes == 0) {

                        // Correct stroke
                        // Entire answer complete, no more remaining strokes
                        itemsAnswered++;

                        hideAnswerPrompt();

                        showWpm();

                        setNextDrillItem();

                        addSample(steno, [steno]); // XXX NEW XXX

                        showDrillItem();
                    }
                    else if (remainingStrokes > 0) {

                        // Correct stroke
                        // There are more strokes remaining
                        currentStroke++;

                        jQuery('#txtInput').val(answerGivenSoFar);

                        possibleAnswerClick(currentTdAnswer + 1);
                    }
                    else {
                        // Incorrect stroke
                        showAnswerPrompt(steno);
                    }
                }
                else {
                    // Asterisk key
                    // Delete last stroke
                    if (answerGivenSoFar.length > 0) {

                        currentStroke--;

                        var answerSoFarWithoutSlash = answerGivenSoFar.substring(answerGivenSoFar.length - 1, 1);

                        var indexOfLastSlash = answerSoFarWithoutSlash.lastIndexOf("/");

                        if (indexOfLastSlash < 0) {
                            answerGivenSoFar = "";
                        }
                        else {
                            answerGivenSoFar = answerSoFarWithoutSlash.substring(0, indexOfLastSlash);
                        }

                        jQuery('#txtInput').val(answerGivenSoFar);

                        possibleAnswerClick(currentTdAnswer + 1);
                    }
                }
            }

            clearKeys();
        }
    }
}

</script>
</body>
</html>
