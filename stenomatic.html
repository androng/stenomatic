<!--

Things I know how to implement:

    * MAXIMIZE CONFUSION.  Right now we have a simple Markov
      process which avoids similar words; we can furthermore
      try to force vowel to skip between left and right, force
      different finger and force contrary motion (one finger goes
      left while the other goes right; also same motion),
      using different probability distributions.

      Confusion is not good when there are only two choices (vowel)
      disable it in that case.

    * Markov generated random text based on the input corpus (Ha Ha)

    * Smooth scrolling, use
      http://stackoverflow.com/questions/2905867/how-to-scroll-to-specific-item-using-jquery

    * Custom dictionary support.

    * Colorized letters per word types see
      http://stenoknight.com/plover/ploverdemo/ploverdemo.html

    * Bring back the steno keyboard (toggleable, also how heavy
      hint should be given should be toggleable), BTW colorize
      it same as above!

    * Download your data, load it into R and do stats analysis
      on it. (Is this actually useful?)

    * Karaoke mode: take a cue file and do time trials. (Need to
      give user a grace period since the subfiles will not necessarily
      be the right place.) Use YOUTUBE to source music cheaply.

    * Time trial mode: karaoke mode but without the karaoke
      (Low priority, you can simulate this using a metronome).

    * Idea for rendering misstrokes: key heatmap.  Increase color
      depth if you keep stroking the key instead of the right
      one (which is highlighted in some way).  Benefit of this
      scheme: you can aggregate when stroking the same word
      multiple times.  Maybe more difficult if trying to aggregate
      per chord; maybe just split left/right/vowel.

Things which will be annoying to implement.

    * Fix stemmification/suffixization.  StenoLearner does this
      property but I can't stand waiting for its dictionary to
      load.  Maybe add some ad hoc rules to fix it.

Things which would be nice to implement, but which I don't know
how to spec.

    * Visual representation of how long it took to do words.  Heat map?
      Some sort of coloring?  Little bars?  Sizing?  Need to play
      around with a few options, what we have right now is NOT very good.

    * Per key/chord statistics.  We have a teensy bit of this in
      the post mortem code, unclear how to package this up in
      a better format.

    * Aggregated data: if you do the same test set multiple times,
      give some ability to track progress over time.  Preferably
      have some sort of server to store tests and your data, but
      this will be annoying to setup and maintain.  WPMs at bare
      minimum, also test data.

    * I'm pretty sure there is at least some hysterisis going on
      between previous and next stroke, but I don't know how
      to visualize this.  Musically it's like "intervals", but
      there are a lot more intervals.

This is like, a non-gameified version of many of the minigames
imagined in http://plover.stenoknight.com/2011/04/hover-plover.html

Bugs:

    * Partial strokes UI is pretty confusing.  Can we chunk up the
      words somehow to give partial progress?  Seems algorithmically tricky.

    * WPM is nonsense if you use the backwards/forwards arrow

-->
<html>
<head>
<title>Stenomatic 9000</title>
<link rel="prefetch" href="dict.json">
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<style>
html {overflow-y: scroll;}
#viewport { font-size: 2em; }
.brief {color: blue;}
.nostroke {color: purple;}
.done {color: grey;}
.current {background:#DDD}
.complete {background:#9F9}
.incorrect {color: #F99;}
#chkPlainTextInput {display: none}
.boxLabel {margin-right:1em;}
h2 {font-size:1.2em;}
td {vertical-align: top;}
.many {margin-left:2em;text-indent:-2em;}
.many .done {color: #000}
.many .incorrect {color: #EEE; background:#600;}
.over {font-size:2em; padding:0;}
.under {font-size:0.8em; padding:0;padding-top:-0.4em;padding-bottom:0.4em;font-family:Arial;}
.under .diff sub {color:red;}
.under .diff sup {color:green;}
.under .errorCount {color:red;}
.unit {cursor: pointer; display:inline;text-align:center; border-collapse: collapse; border-spacing: 0;}
.wordstat {}
</style>
</head>
<body>
<div id="viewport"><em>Loading Dictionary...</em></div>
<div>
<input type="text" id="txtInput">
<!--
<input type="submit" value="&lt;" id="prevbtn">
<input type="submit" value="&gt;" id="nextbtn">
-->
<input type="submit" value="Restart" id="loadbtn2">
</div>
<div id="barometer"></div>
<div id="stats"></div>
<span id="prompt"></span>
<input type="checkbox" id="chkPlainTextInput">
<hr>
<p>
<em>Greetings mortal, I am the Stenomatic 9000</em>. To utilize my services, copy paste some exercise material (for example, the exercises in <a href="https://sites.google.com/site/ploverdoc/lesson-1-fingers-and-keys">Learn Plover</a>) and select what kind of exercise you want to do.  Then press load and go! (If you change any settings, you will need to reload the exercise.)  I am a derivative work of <a href="http://qwertysteno.com/Home/">Qwerty Steno</a>, with whom I share the QWERTY input handling code.
</p>
<h2>Mode:</h2>
<table id="modebtns">
    <tr>
        <td><input type="radio" name="mode" value="accuracy" onclick="updateMode()" checked></td>
        <td><strong class="boxLabel">Require correct stroke</strong> If you misstroke, the stroke is rejected; you cannot move on until you get the stroke right.  When you are done, you will see how long it took for you to stroke a word, as well as how many misstrokes were made before the word was finished.</td>
    </tr>
    <tr>
        <td><input type="radio" name="mode" value="speed" onclick="updateMode()"></td>
        <td><strong class="boxLabel">Advance on misstroke</strong> If you misstroke a word, you'll move onto the next one.  You can go back and fix your error with the asterisk.  When you are done, you will be shown all of your misstrokes and a suggested correction for them.  Try using this mode with a metronome!</td>
    </tr>
</table>
<h2>Style:</h2>
<table id="stylebtns">
    <tr>
        <td><input type="radio" name="style" value="script" checked></td>
        <td><strong class="boxLabel">Script</strong> Follow the script in the source order.</td>
    </tr>
    <tr>
        <td><input type="radio" name="style" value="randomized"></td>
        <td><strong class="boxLabel">Randomized</strong> Generate <input type="text" id="randomLength" value="100" size="1"> random words sampled from the source input (weighted based on occurrence frequency).<br><input type="checkbox" id="randomShift"> Maximize finger movement by preventing similar words from being adjacent.</td>
    </tr>
</table>
<h2>Difficulty:</h2>
You can reduce the difficulty of an exercise by stroking a subset of the keys of the true strokes: this is good for working on muscle memory.  <input type="submit" value="Enable all" onclick="$('#difficultybtns input').prop('checked', true);" /> <input type="submit" value="Clear all" onclick="$('#difficultybtns input').prop('checked', false);" />
<table id="difficultybtns">
    <tr>
        <td><input type="checkbox" id="enable-left" value="left" checked></td>
        <td><strong class="boxLabel">Left hand keys</strong> (STKPWHR)
        </td>
    </tr>
    <tr>
        <td><input type="checkbox" id="enable-left-vowels" value="vowel" checked></td>
        <td><strong class="boxLabel">Left vowel keys</strong> (AO)
        </td>
    </tr>
    <tr>
        <td><input type="checkbox" id="enable-right-vowels" value="vowel" checked></td>
        <td><strong class="boxLabel">Right vowel keys</strong> (EU)
        </td>
    </tr>
    <tr>
        <td><input type="checkbox" id="enable-right" value="right" checked></td>
        <td><strong class="boxLabel">Right hand</strong> (FRPBLGTSDZ)
        </td>
    </tr>
</table>
<h2>Filter:</h2>
You can skip difficult words by filtering them out.  <input type="submit" value="Enable all" onclick="$('#filterbtns input').prop('checked', true);" /> <input type="submit" value="Clear all" onclick="$('#filterbtns input').prop('checked', false);" />
<table id="filterbtns">
    <tr>
        <td><input type="checkbox" id="enable-asterisk" value="asterisk" checked></td>
        <td><strong class="boxLabel">Asterisk</strong> If this is unchecked, words which must be disambiguated with an asterisk will not be tested.
        </td>
    </tr>
    <tr>
        <td><input type="checkbox" id="enable-multistroke" value="multistroke" checked></td>
        <td><strong class="boxLabel">Multi-stroke</strong> If this is unchecked, words which require multiple strokes will not be tested.  (Watch out if they're briefed, however!)
        </td>
    </tr>
    <tr>
        <td><input type="checkbox" id="enable-briefs" value="briefs" checked></td>
        <td><strong class="boxLabel">Briefs</strong> If this is unchecked, briefed words will not be tested.
        </td>
    </tr>
    <tr>
        <td><input type="checkbox" id="enable-misstrokes" value="briefs" checked></td>
        <td><strong class="boxLabel">Misstrokes</strong> If this is unchecked, common misstrokes which would have been accepted by Plover will not be accepted.
        </td>
    </tr>
</table>
<input type="submit" value="Clear" id="clearbtn">
<input type="submit" value="Load" id="loadbtn">
<select id="select-sample"><option value="data">(Preloaded data)</option></select>
        <div><textarea id="data" cols="80" rows="20">
The quick brown fox jumps over the lazy dog.
Pack my box with five dozen liquor jugs.
</textarea>
<div style="display:none;" id="samples">
    <textarea id="learnplover-1-left" name="[Learn Plover] 1. One-Syllable Words (Left)">
    'sap' 'sag' 'sat' 'sass' 'sad' 'sop' 'sob' 'sell' 'set' 'says'
    'tar' 'tap' 'tab' 'tag' 'tad' 'tour' 'top' 'toll' 'tell' 'tough' 'tub' 'tug'
    'car' 'cap' 'cab' 'cat' 'cad' 'core' 'cop' 'cog' 'cot' 'cod' 'keg' 'cuff' 'cur' 'cup' 'cub' 'cull' 'cut' 'cuss'
    'pal' 'pat' 'pass' 'pad' 'pour' 'poll' 'pot' 'pod' 'pep' 'peg' 'pet' 'puff' 'pup' 'pub' 'pull' 'pug' 'put' 'pus'
    'war' 'wag' 'wad' 'was' 'wore' 'web' 'well' 'wet' 'wed'
    'half' 'hag' 'hat' 'had' 'has' 'hop' 'hog' 'hot' 'her' 'hell' 'head' 'huff' 'hub' 'hull' 'hug' 'hut'
    'rap' 'rag' 'rat' 'roar' 'rob' 'roll' 'rot' 'rod' 'red' 'rough' 'rub' 'rug' 'rut'
    </textarea>
    <textarea id="learnplover-1-right" name="[Learn Plover] 1. One-Syllable Words (Right)">
    'half' 'tough' 'cuff' 'puff' 'huff' 'rough'
    'tar' 'car' 'war' 'tour' 'core' 'pour' 'wore' 'roar' 'her' 'cur' 
    'sap' 'tap' 'cap' 'rap' 'sop' 'top' 'cop' 'hop' 'pep' 'cup' 'pup'
    'tab' 'cab' 'sob' 'rob' 'web' 'tub' 'cub' 'pub' 'rub'
    'pal' 'toll' 'poll' 'roll' 'sell' 'tell' 'well' 'hell' 'cull' 'pull' 'hull'
    'sag' 'tag' 'wag' 'hag' 'rag' 'cog' 'hog' 'keg' 'peg' 'tug' 'pug' 'hug' 'rug'
    'sat' 'cat' 'pat' 'hat' 'rat' 'cot' 'pot' 'hot' 'rot' 'set' 'pet' 'wet' 'cut' 'put' 'hut' 'rut'
    'sass' 'pass' 'cuss' 'pus'
    'sad' 'tad' 'cad' 'pad' 'wad' 'had' 'cod' 'pod' 'wed' 'head' 'red'
    'has' 'says' 'was'
    </textarea>
    <textarea id="learnplover-3a-1" name="[Learn Plover] 3A-1. The Fifth Vowel Key">
    'still', 'rig', 'hit', 'sip'
    'sir', 'skirt'
    'crypt', 'syrup'
    'pig' 'rift' 'scribble' 'rid' 'river'
    'hid' 'wilt' 'wig' 'wit' 'spill'
    </textarea>
    <textarea id="learnplover-3a-2" name="[Learn Plover] 3A-2. Long Vowel Chords">
    'aids' 'ace' 'ate' 'able' 'ape' 'raid' 'raise' 'rail' 'rate' 'pay' 'paid' 'pace' 'tape' 'spray' 'praise'
    'weaver' 'trees' 'eel' 'eat' 'evil' 'ear' 'heat' 'heap' 'wield' 'weird' 'peer' 'priest' 'tree' 'tweeze' 'tweed' 'seat' 'cease' 'seed' 'seize' 'secrete'
    'ire' 'I'll' 'ice' 'rife' 'ripe' 'right' 'height' 'wild' 'pipe' 'pride' 'prize' 'kite' 'type' 'spite' 'drive'
    'hope' 'spore' 'post' 'sold' 'prose' 'ode' 'oat' 'over' 'robe' 'rope' 'roar' 'rove' 'host' 'wove' 'wrote' 'pole' 'pose' 'cope' 'coat' 'code' 'crow' 'told'
    'cube' 'use' 'rude' 'rule' 'pure' 'prude' 'Proust' 'cure' 'cruel' 'crude' 'cruise' 'truce' 'truth' 'spew' 'skew'
    </textarea>
    <textarea id="learnplover-3a-3" name="[Learn Plover] 3A-3. Dipthongs">
    'all' 'awful' 'raw' 'call' 'caught' 'crawl' 'sprawl' 'scald' 'straw' 'halt' 'hall' 'wall'
    'out' 'how' 'howl' 'house' 'pout' 'power' 'prowl' 'tower' 'spouse' 'sprout' 'scour'
    'soy' 'oil' 'coil' 'toil' 'soil'
    </textarea>
    <textarea id="learnplover-3a-4" name="[Learn Plover] 3A-4. Vowel Disambiguator Chords">
    'wheel' 'wheal' 'read' 'reed' 'reel' 'real' 'heel' 'heal' 'hear' 'here' 'ware' 'wear' 'pea' 'pee' 'peace' 'piece' 'tee' 'tea' 'sea' 'see'
    'tail' 'tale' 'sale' 'sail' 'stare' 'stair' 'waist' 'waste'
    'hood' 'rude' 'pool' 'crew' 'soot' 'truce' 'school' 'ruse'
    'road' 'rode' 'roar' 'toad' 'soar' 'sore'
    </textarea>
    <textarea id="learnplover-3b" name="[Learn Plover] 3B. The Missing Keys">
    'due' 'duffer' 'deferral' 'devil' 'double' 'drug' 'depress' 'desire' 'dessert' 'destroyed'
    'feral' 'ford' 'for' 'phrase' 'fierce' 'fable' 'feeble' 'sphere' 'fries'
    'leader' 'lace' 'letter' 'lust' 'lovers'
    'glad' 'glare' 'glides' 'give' 'get' 'group' 'guest' 'guide' 'gravel' 'cigarette' 'goblet'
    'bored' 'board' 'bruise' 'buyer' 'bobble' 'brutal'
    'zest' 'zap' 'zag'
    'vile' 'vase' 'virus'
    'eke' 'rockets' 'correct' 'quake' 'task'
    </textarea>
    <textarea id="learnplover-3c" name="[Learn Plover] 3C. The Remaining Single Letters">
    'nag' 'nap' 'nab' 'nut' 'never' 'nestle' 'nod' 'nest' 'nerd'
    'pent' 'parent' 'went' 'earns' 'rant' 'hunt' 'hand' 'panel' 'stun'
    'must' 'muffle' 'maggot' 'mallet' 'smuggle' 'morals'
    'arm' 'rum' 'harm' 'tempt' 'term'
    'calmed' 'palm' 'qualms'
    'jut' 'jug' 'just' 'jest' 'jets' 'job' 'jostle' 'jazz' 'jagged'
    'urge' 'edge' 'average' 'purge' 'trudge' 'storage'
    'yard' 'yet' 'yacht' 'yurt'
    </textarea>
    <textarea id="learnplover-3c-cumulative" name="[Learn Plover] 3C. Including Sounds From Previous Lessons">
    'noun' 'inhibit' 'nudge' 'notes' 'knack' 'enacts' 'neck' 'known' 'knock' 'gnome' 'noise' 'novice' 'named' 'neural' 'snide' 'announce'
    'loin' 'donor' 'winner' 'dinner' 'learned' 'lend' 'allowance' 'flaunt' 'deference' 'different' 'dance' 'diner' 'demand' 'grunt' 'grant' 'gleans' 'severance' 'cement' 'design'
    'mound' 'mourn' 'maim' 'matter' 'commit' 'commend' 'smudge' 'smuggle' 'semester'
    'forms' 'primed' 'serum' 'time' 'hermit' 'maim' 'plumb' 'dream' 'gym' 'germ' 'jam' 'blame' 'bottom' 'grammar'
    'balm' 'psalm'
    'judge' 'journal' 'join' 'joyful' 'jam' 'gerunds'
    'forge' 'budgets' 'average' 'leverage' 'merge' 'beige' 'carriage' 'fidget' 'frigid' 'digit' 'gadget' 'garage' 'grudge' 'turgid'
    'year' 'yearn' 'yolk'
    </textarea>
    <textarea id="learnplover-3d" name="[Learn Plover] 3D. Digraphs">
    'thefts' 'thud' 'thus' 'thug'
    'hath' 'earth' 'oath' 'health' 'wealth' 'worth' 'path' 'troth'
    'chess' 'chest' 'chart' 'chat' 'chop' 'chore' 'chaff'
    'touch' 'etch' 'ratchet' 'hutch' 'hatch' 'watch' 'patch' 'catch' 'crutch' 'such' 'sketch' 'stretch' 'retch'
    'shell' 'shuffled' 'shall' 
    'ash' 'rush' 'rash' 'hush' 'hash' 'wash' 'push' 'posh' 'crush' 'crash' 'trash' 'squash' 'stash'
    'anger' 'storing' 'rung' 'rang' 'prong' 'tongue' 'twang' 'song' 'stung' 'strong'
    'sponge' 'orange' 
    </textarea>
    <textarea id="learnplover-3d-cumulative" name="[Learn Plover] 3D. Including Sounds From Previous Lessons">
    'thing' 'thence' 'them' 'thumb' 'thrill' 'throng' 'thrash'
    'seethe' 'method' 'math' 'birth' 'breath' 'fifth' 'death' 'sleuth' 'blithe' 'growth'
    'choose' 'chasm' 'chuck' 'check' 'churn' 'cherub' 'chin' 'channel' 'chant' 'chance' 'chive' 'charm'
    'bleach' 'much' 'latch' 'leech' 'match' 'botch' 'fetch' 'ditch' 'glitch' 'vouch' 'slouch' 'smooch' 'splotch'
    'shim' 'slime' 'shrewd' 'shrine' 'shuck' 'shark' 'shock' 'sheesh' 'shrivel' 'sugar'
    'lash' 'mesh' 'mash' 'plush' 'bush' 'brush' 'fish' 'fresh' 'flush' 'flesh' 'flash' 'dash' 'delish' 'gosh' 'gash' 'shush' 'slash' 'smush' 'slosh' 'splash' 'squish' 'Irish'
    'anger' 'finger' 'dung' 'lung' 'ping' 'pong' 'among' 'bring' 'young' 'fang' 'flung' 'gang' 'belong'
    'change' 'range' 'hinge' 'lounge' 'plunge' 'cringe' 'tinge' 'fringe' 'derange' 'grunge' 'syringe'
    </textarea>
    <textarea id="learnplover-3e" name="[Learn Plover] 3E. Common Compound Clusters">
    'hemp' 'trump' 'rump' 'romp' 'ramp' 'pump' 'camp' 'cramp' 'tamp' 'pomp'
    'curve' 'carve' 'serve' 'swerve' 'starve' 
    'squelch'
    'hulk' 'calc' 'sulk' 'talc'
    'rank' 'honk' 'wonk' 'prank' 'crank' 'tank'
    'session' 'option' 'ration' 'portion' 'passion' 'cushion' 'caption' 'suppression'
    'section' 'correction' 'suction'
    'arch' 'ranch' 'hunch' 'porch' 'crunch' 'quench' 'torch' 'trench' 'stench' 'starch' 
    </textarea>
    <textarea id="learnplover-3e-cumulative" name="[Learn Plover] 3E. Including Sounds From Previous Lessons">
    'limp' 'blimp' 'chomp' 'clamp' 'damp' 'slump' 'shrimp' 'jump'
    'nerve' 'verve' 'marvel'
    'village' 'mulch' 'bulge' 'belch' 'bilge' 'gulch' 'pillage'
    'ilk' 'milk' 'bulk' 'silk' 'bilk'
    'wink' 'mink' 'plank' 'brink' 'blink' 'blank' 'flank' 'flunk' 'dank' 'drink' 'gunk' 'junk' 'link' 'chunk'
    'lesion' 'provision' 'fusion' 'lotion' 'operation' 'mission' 'motion' 'pollution'
    'election' 'auction' 'correction' 'collection' 'fraction' 'friction' 'depiction' 'selection' 'seduction'
    'finch' 'clench' 'branch' 'march' 'lurch' 'lynch' 'birch' 'brunch' 'church' 'drench'
    </textarea>
    <textarea id="learnplover-cumulative" name="[Learn Plover] All Exercises">
    'sap' 'sag' 'sat' 'sass' 'sad' 'sop' 'sob' 'sell' 'set' 'says'
    'tar' 'tap' 'tab' 'tag' 'tad' 'tour' 'top' 'toll' 'tell' 'tough' 'tub' 'tug'
    'car' 'cap' 'cab' 'cat' 'cad' 'core' 'cop' 'cog' 'cot' 'cod' 'keg' 'cuff' 'cur' 'cup' 'cub' 'cull' 'cut' 'cuss'
    'pal' 'pat' 'pass' 'pad' 'pour' 'poll' 'pot' 'pod' 'pep' 'peg' 'pet' 'puff' 'pup' 'pub' 'pull' 'pug' 'put' 'pus'
    'war' 'wag' 'wad' 'was' 'wore' 'web' 'well' 'wet' 'wed'
    'half' 'hag' 'hat' 'had' 'has' 'hop' 'hog' 'hot' 'her' 'hell' 'head' 'huff' 'hub' 'hull' 'hug' 'hut'
    'rap' 'rag' 'rat' 'roar' 'rob' 'roll' 'rot' 'rod' 'red' 'rough' 'rub' 'rug' 'rut'
    'still', 'rig', 'hit', 'sip'
    'sir', 'skirt'
    'crypt', 'syrup'
    'pig' 'rift' 'scribble' 'rid' 'river'
    'hid' 'wilt' 'wig' 'wit' 'spill'
    'aids' 'ace' 'ate' 'able' 'ape' 'raid' 'raise' 'rail' 'rate' 'pay' 'paid' 'pace' 'tape' 'spray' 'praise'
    'weaver' 'trees' 'eel' 'eat' 'evil' 'ear' 'heat' 'heap' 'wield' 'weird' 'peer' 'priest' 'tree' 'tweeze' 'tweed' 'seat' 'cease' 'seed' 'seize' 'secrete'
    'ire' 'I'll' 'ice' 'rife' 'ripe' 'right' 'height' 'wild' 'pipe' 'pride' 'prize' 'kite' 'type' 'spite' 'drive'
    'hope' 'spore' 'post' 'sold' 'prose' 'ode' 'oat' 'over' 'robe' 'rope' 'roar' 'rove' 'host' 'wove' 'wrote' 'pole' 'pose' 'cope' 'coat' 'code' 'crow' 'told'
    'cube' 'use' 'rude' 'rule' 'pure' 'prude' 'Proust' 'cure' 'cruel' 'crude' 'cruise' 'truce' 'truth' 'spew' 'skew'
    'all' 'awful' 'raw' 'call' 'caught' 'crawl' 'sprawl' 'scald' 'straw' 'halt' 'hall' 'wall'
    'out' 'how' 'howl' 'house' 'pout' 'power' 'prowl' 'tower' 'spouse' 'sprout' 'scour'
    'soy' 'oil' 'coil' 'toil' 'soil'
    'wheel' 'wheal' 'read' 'reed' 'reel' 'real' 'heel' 'heal' 'hear' 'here' 'ware' 'wear' 'pea' 'pee' 'peace' 'piece' 'tee' 'tea' 'sea' 'see'
    'tail' 'tale' 'sale' 'sail' 'stare' 'stair' 'waist' 'waste'
    'hood' 'rude' 'pool' 'crew' 'soot' 'truce' 'school' 'ruse'
    'road' 'rode' 'roar' 'toad' 'soar' 'sore'
    'due' 'duffer' 'deferral' 'devil' 'double' 'drug' 'depress' 'desire' 'dessert' 'destroyed'
    'feral' 'ford' 'for' 'phrase' 'fierce' 'fable' 'feeble' 'sphere' 'fries'
    'leader' 'lace' 'letter' 'lust' 'lovers'
    'glad' 'glare' 'glides' 'give' 'get' 'group' 'guest' 'guide' 'gravel' 'cigarette' 'goblet'
    'bored' 'board' 'bruise' 'buyer' 'bobble' 'brutal'
    'zest' 'zap' 'zag'
    'vile' 'vase' 'virus'
    'eke' 'rockets' 'correct' 'quake' 'task'
    'nag' 'nap' 'nab' 'nut' 'never' 'nestle' 'nod' 'nest' 'nerd'
    'pent' 'parent' 'went' 'earns' 'rant' 'hunt' 'hand' 'panel' 'stun'
    'must' 'muffle' 'maggot' 'mallet' 'smuggle' 'morals'
    'arm' 'rum' 'harm' 'tempt' 'term'
    'calmed' 'palm' 'qualms'
    'jut' 'jug' 'just' 'jest' 'jets' 'job' 'jostle' 'jazz' 'jagged'
    'urge' 'edge' 'average' 'purge' 'trudge' 'storage'
    'yard' 'yet' 'yacht' 'yurt'
    'noun' 'inhibit' 'nudge' 'notes' 'knack' 'enacts' 'neck' 'known' 'knock' 'gnome' 'noise' 'novice' 'named' 'neural' 'snide' 'announce'
    'loin' 'donor' 'winner' 'dinner' 'learned' 'lend' 'allowance' 'flaunt' 'deference' 'different' 'dance' 'diner' 'demand' 'grunt' 'grant' 'gleans' 'severance' 'cement' 'design'
    'mound' 'mourn' 'maim' 'matter' 'commit' 'commend' 'smudge' 'smuggle' 'semester'
    'forms' 'primed' 'serum' 'time' 'hermit' 'maim' 'plumb' 'dream' 'gym' 'germ' 'jam' 'blame' 'bottom' 'grammar'
    'balm' 'psalm'
    'judge' 'journal' 'join' 'joyful' 'jam' 'gerunds'
    'forge' 'budgets' 'average' 'leverage' 'merge' 'beige' 'carriage' 'fidget' 'frigid' 'digit' 'gadget' 'garage' 'grudge' 'turgid'
    'year' 'yearn' 'yolk'
    'thefts' 'thud' 'thus' 'thug'
    'hath' 'earth' 'oath' 'health' 'wealth' 'worth' 'path' 'troth'
    'chess' 'chest' 'chart' 'chat' 'chop' 'chore' 'chaff'
    'touch' 'etch' 'ratchet' 'hutch' 'hatch' 'watch' 'patch' 'catch' 'crutch' 'such' 'sketch' 'stretch' 'retch'
    'shell' 'shuffled' 'shall' 
    'ash' 'rush' 'rash' 'hush' 'hash' 'wash' 'push' 'posh' 'crush' 'crash' 'trash' 'squash' 'stash'
    'anger' 'storing' 'rung' 'rang' 'prong' 'tongue' 'twang' 'song' 'stung' 'strong'
    'sponge' 'orange' 
    'thing' 'thence' 'them' 'thumb' 'thrill' 'throng' 'thrash'
    'seethe' 'method' 'math' 'birth' 'breath' 'fifth' 'death' 'sleuth' 'blithe' 'growth'
    'choose' 'chasm' 'chuck' 'check' 'churn' 'cherub' 'chin' 'channel' 'chant' 'chance' 'chive' 'charm'
    'bleach' 'much' 'latch' 'leech' 'match' 'botch' 'fetch' 'ditch' 'glitch' 'vouch' 'slouch' 'smooch' 'splotch'
    'shim' 'slime' 'shrewd' 'shrine' 'shuck' 'shark' 'shock' 'sheesh' 'shrivel' 'sugar'
    'lash' 'mesh' 'mash' 'plush' 'bush' 'brush' 'fish' 'fresh' 'flush' 'flesh' 'flash' 'dash' 'delish' 'gosh' 'gash' 'shush' 'slash' 'smush' 'slosh' 'splash' 'squish' 'Irish'
    'anger' 'finger' 'dung' 'lung' 'ping' 'pong' 'among' 'bring' 'young' 'fang' 'flung' 'gang' 'belong'
    'change' 'range' 'hinge' 'lounge' 'plunge' 'cringe' 'tinge' 'fringe' 'derange' 'grunge' 'syringe'
    'hemp' 'trump' 'rump' 'romp' 'ramp' 'pump' 'camp' 'cramp' 'tamp' 'pomp'
    'curve' 'carve' 'serve' 'swerve' 'starve' 
    'squelch'
    'hulk' 'calc' 'sulk' 'talc'
    'rank' 'honk' 'wonk' 'prank' 'crank' 'tank'
    'session' 'option' 'ration' 'portion' 'passion' 'cushion' 'caption' 'suppression'
    'section' 'correction' 'suction'
    'arch' 'ranch' 'hunch' 'porch' 'crunch' 'quench' 'torch' 'trench' 'stench' 'starch' 
    'limp' 'blimp' 'chomp' 'clamp' 'damp' 'slump' 'shrimp' 'jump'
    'nerve' 'verve' 'marvel'
    'village' 'mulch' 'bulge' 'belch' 'bilge' 'gulch' 'pillage'
    'ilk' 'milk' 'bulk' 'silk' 'bilk'
    'wink' 'mink' 'plank' 'brink' 'blink' 'blank' 'flank' 'flunk' 'dank' 'drink' 'gunk' 'junk' 'link' 'chunk'
    'lesion' 'provision' 'fusion' 'lotion' 'operation' 'mission' 'motion' 'pollution'
    'election' 'auction' 'correction' 'collection' 'fraction' 'friction' 'depiction' 'selection' 'seduction'
    'finch' 'clench' 'branch' 'march' 'lurch' 'lynch' 'birch' 'brunch' 'church' 'drench'
    </textarea>
    <textarea id="ploverwiki-common" name="[Plover Wiki] Practice Sentences with Common English Words">
    So is this working? 
    Take that! 
    In general, all are found. 
    Some new, or not, interest him. 
    Through time, my days made years. 
    There can be only one. 
    Most may make many more. 
    When will you? 
    If I, like he, were them, our people would now will well. 
    On such a day, no other said. 
    The great first country was for her. 
    Who other than she? 
    Being between out, over, under, and upon, every good must last. 
    Where were we? 
    What has been here before is his. 
    After all, it is about that which you are from. 
    What can they have from these today? 
    By and large, it’s made very well. 
    Since they were up to it, their will was had. 
    At its general time, but still while they were here. 
    Of which one is that? 
    </textarea>
</div></div>
<script>
// ----------------------------------------------------------------------------
// Dictionary initialization
var rdata = {"i": ["EU"]};
/*
$.getJSON("dict.json", function(dict) {
        $.each( dict, function(k,rv) {
            if (/\d/.test(k)) return;
            var v = rv.toLowerCase();
            if (rdata.hasOwnProperty(v)) { // watch
                rdata[v].push({stroke: k});
            } else {
                rdata[v] = [{stroke: k}];
            }
            });
        init();
        });
        */
$.getJSON("categorized.json", function(dict) {
        $.each( dict, function(i,e) {
            var k = e[1];
            var rv = e[0];
            var cat = e[2];
            if (/\d/.test(k)) return;
            var v = rv.toLowerCase();
            var stroke = {stroke: k, category: cat.split(" ")}
            if (rdata.hasOwnProperty(v)) { // watch
                rdata[v].push(stroke);
            } else {
                rdata[v] = [stroke];
            }
            });
        init();
        });

function depunctuateWord(rword) {
    return rword.replace(/[!"#$%&\\\(\)*+,-.\/:;<=>?@\[\]\^_`{|}~]/g, "").replace(/^'/, "").replace(/'$/, "");
}
function cleanWord(rword) {
    return depunctuateWord(rword).toLowerCase();
}
function wordStrokes(word) {
    var r = rdata[cleanWord(word)];
    return r ? r : [];
}
function bestStroke(strokes) {
    var cand;
    $.each(strokes, function(i, s) {
            cand = take_best(cand, s);
            });
    return cand;
}
function filterDifficultyOnlyGood(stroke_entry) {
    if ($.inArray("misstroke", stroke_entry.category) != -1) return false;
    return filterDifficulty(stroke_entry);
}
function filterDifficulty(stroke_entry) {
    var stroke = stroke_entry.stroke;
    // handle the filters first
    if (!$("#enable-briefs").prop("checked") && $.inArray("brief", stroke_entry.category) != -1) {
        return false;
    }
    if (!$("#enable-misstrokes").prop("checked") && $.inArray("misstroke", stroke_entry.category) != -1) {
        return false;
    }
    if (!$("#enable-asterisk").prop("checked") && stroke.contains("*")) {
        return false;
    }
    if (!$("#enable-multistroke").prop("checked") && stroke.contains("/")) {
        return false;
    }
    var strokes = stroke.split("/");
    var r = [];
    for (var i = 0; i < strokes.length; i++) {
        var leftLetters = "", rightLetters = "", middleLetters = "";
        if ($("#enable-left").prop("checked")) {
            leftLetters = getLeftLettersFromSteno(strokes[i]);
        }
        if ($("#enable-left-vowels").prop("checked") || $("#enable-right-vowels").prop("checked") ) {
            middleLetters = getMiddleLettersFromSteno(strokes[i]);
            if (!$("#enable-left-vowels").prop("checked") && middleLetters.match(/[AO]/)) {
                return false;
            }
            if (!$("#enable-right-vowels").prop("checked") && middleLetters.match(/[EU]/)) {
                return false;
            }
        } else {
            if (strokes[i].contains("*")) middleLetters = "*";
        }
        if ($("#enable-right").prop("checked")) {
            rightLetters = getRightLettersFromSteno(strokes[i]);
        }
        if (middleLetters.length == 0 && rightLetters.length > 0) {
            middleLetters = "-";
        }
        var seg = leftLetters + middleLetters + rightLetters;
        if (!seg) return;
        r.push(seg);
    }
    return r.join("/");
    //var steno = stroke.split('/')[0];
}
// TODO: lift "chordifying" code from https://plover.goeswhere.com/
// so we can get per-chord stats

// todo: reverse array
function stenoArray(steno) {
    var left = getLeftLettersFromSteno(steno);
    var right = getRightLettersFromSteno(steno);
    var r = [];
    $.each(["S","T","K","P","W","H","R"], function(i,l) { r.push(left.contains(l)); });
    $.each(["A", "O", "*", "E", "U"], function(i,l) { r.push(steno.contains(l)); });
    $.each(["F","R","P","B","L","G","T","S","D","Z"], function(i,l) { r.push(right.contains(l)); } );
    return r;
}

// ----------------------------------------------------------------------------
// Main user interface
// data is a list of {index: wordcount index, words: list of {word: word}}
var data, cur_line, cur_word;
var currentStroke = 1;
var cur_mode, cur_style;
var samples; // {time: Date, start_time: Date, expected_strokes: [String], actual_stroke: String, line: Number, word: Number}
var stroke_start, exercise_start;
var streak = 0;
var best_streak = 0;
var misstrokes = 0;
var finished = false;

function updateMode() {
    cur_mode = $('input[name=mode]:checked', '#modebtns').val();
}

function updateDifficulty() {
    // cur_difficulty = [$("#enable-vowels").val(), $("#enable-left").val(), $("#enable-right").val(), $("#enable-asterisk").val()];
}

function updateStyle() {
    cur_style = $('input[name=style]:checked', '#stylebtns').val();
}

function updateBarometer() {
    if (!exercise_start) {
        exercise_start = new Date();
    }
    var wpm = Math.round((1000 * 60 * (data[cur_line].index + cur_word)) / ((new Date()).getTime() - exercise_start.getTime()));
    if (wpm > 300) { wpm = 300; }
    // ToDo: WPM is not really right, but doing it this way
    // so that the easier difficulty modes are not completely
    // bogus
    $('#barometer').html("[" + (cur_line + 1) + "/" + data.length + "] <strong>WPM:</strong> " + wpm + ", <strong>Streak:</strong> " + streak + " (best: " + best_streak + "), <strong>Misstrokes:</strong> " + misstrokes);
}

// hmm, I don't know what to actually do with this data
function addSample(actual, expecteds) {
    /*
    samples.push({time: new Date(),
                  start_time: stroke_start,
                  actual_stroke: actual,
                  expected_strokes: expecteds,
                  line: cur_line,
                  word: cur_word});
                  */
    updateBarometer();
}

function init() {
    $("textarea", "#samples").each(function() {
            $("#select-sample").append($("<option>").prop("value", $(this).prop("id")).text($(this).prop("name")));
            });
    $("#select-sample").change(function(e) {
            var t = $(document.getElementById($("#select-sample").val()));
            $("#data").val(t.val());
            });
    $("#txtInput").val(""); // force empty
    $("#loadbtn").click(loadData);
    $("#loadbtn2").click(loadData);
    $("#clearbtn").click(function() {$("#data").val("")});
    $("#txtInput").keyup(keyUp).keydown(keyDown);
    $("#prevbtn").click(function() {
            if (cur_line == 0) {
                cur_word = -1;
                $.each(data[cur_line].words, function(j,word_entry) {
                        word_entry.status = S_PENDING;
                    });
                paintLine();
                nextWord();
                return;
            }
            var i = 1;
            var old_cur_line = cur_line;
            while (cur_line >= old_cur_line && cur_line - i >= 0) {
                cur_line -= i;
                $.each(data[cur_line].words, function(j,word_entry) {
                        word_entry.status = S_PENDING;
                    });
                cur_word = -1;
                paintLine();
                nextWord();
                i++;
            }
        });
    $("#nextbtn").click(function() {
        if (cur_line == data.length - 1) return;
        cur_line++;
        cur_word = -1;
        paintLine();
        nextWord();
        });
    loadData();
    updateMode();
}
var S_PENDING = 0;
var S_INCORRECT = 1;
var S_DONE = 2;
function copyExerciseWord(word_entry) {
    return {word: word_entry.word,
        strokes: word_entry.strokes,
        goodStrokes: word_entry.goodStrokes,
        bestStroke: word_entry.bestStroke,
        bestStrokeArray: word_entry.bestStrokeArray,
        recognized: word_entry.recognized,
        user: word_entry.user.slice(0),
        status: word_entry.status
    }
}
function mkExerciseWord(word, strokes, good_strokes, recognized) {
    var best_stroke = good_strokes.length ? bestStroke(good_strokes) : undefined;
    return {word: word,
        strokes: strokes,
        goodStrokes: good_strokes,
        bestStroke: best_stroke,
        bestStrokeArray: best_stroke ? stenoArray(best_stroke) : undefined,
        recognized: recognized,
        user: [], // what you stroked in
        status: S_PENDING};
}
function getCurrentWord() {
    return data[cur_line].words[cur_word];
}
function loadData() {
    data = [];
    var text = $("#data").val();
    var lines = text.split("\n");
    var c = 0;
    updateStyle();
    updateDifficulty();
    if (cur_style == "script") {
        $.each( lines, function(i,line) {
                var cur = [];
                var sub_c = 0;
                var words = line.split(" ");
                $.each( words, function(i,word) {
                    if (/\S/.test(word)) {
                        var strokes = wordStrokes(word);
                        var t_strokes = mapFilter(strokes, filterDifficulty);
                        var good_strokes = mapFilter(strokes, filterDifficultyOnlyGood);
                        if (good_strokes) {
                            sub_c++;
                        }
                        cur.push(mkExerciseWord(word, t_strokes, good_strokes, !!strokes.length));
                    }
                    });
                if (cur.length > 0) data.push({index: c, words: cur});
                c += sub_c;
                });
    } else if (cur_style == "randomized") {
        var count = parseInt($("#randomLength").val());
        var corpus = [];
        $.each( lines, function(i,line) {
                var words = line.split(" ");
                $.each( words, function(i, rword) {
                    var word = depunctuateWord(rword);
                    var strokes = wordStrokes(word);
                    var t_strokes = mapFilter(strokes, filterDifficulty);
                    var good_strokes = mapFilter(strokes, filterDifficultyOnlyGood);
                    if (/\S/.test(word) && good_strokes.length) {
                        corpus.push(mkExerciseWord(word, t_strokes, good_strokes, true));
                    }
                    });
                });
        if (!corpus.length) {
            $("#viewport").html("<em>No data</em>");
            return;
        }
        // Make me a Markov chain
        $.each(corpus, function(i1,e1) {
            if ($("#randomShift").is(':checked')) {
                var scores = [];
                $.each(corpus, function(i2,e2) {
                        // TODO refactor out acceptability function
                        var score = 0;
                        for (var k = 0; k < e1.bestStrokeArray.length; k++) {
                            if (e1.bestStrokeArray[k] == 1 && e2.bestStrokeArray[k] == 1) score++;
                        }
                        if (!scores[score]) scores[score] = [];
                        scores[score].push(e2);
                    });
                for (var j = 0; j < scores.length; j++) {
                    if (scores[j].length) {
                        e1.transitions = scores[j];
                        break;
                    }
                }
                if (!e1.transitions || !e1.transitions.length) {
                    e1.transitions = corpus;
                }
            } else {
                e1.transitions = corpus;
            }
            });
        var cur = [];
        var transitions = corpus;
        for (var i = 0; i < count; i++) {
            if (i % 8 == 0) {
                cur = [];
                data.push({index: i, words: cur});
            }
            var cand = transitions[Math.floor(Math.random() * transitions.length)];
            cur.push(copyExerciseWord(cand));
            transitions = cand.transitions;
        }
    }
    if (data.length) startData();
}
function startData() {
    cur_line = 0;
    cur_word = -1;
    exercise_start = false;
    samples = [];
    streak = 0;
    best_streak = 0;
    misstrokes = 0;
    stroke_start = false;
    $("#txtInput").removeClass("complete");
    $("#txtInput").prop("disabled", false);
    $("#prevbtn").prop("disabled", false);
    $("#nextbtn").prop("disabled", false);
    finished = false;
    $('#stats').html("");
    $('#barometer').html("");
    paintLine();
    nextWord();
}
function paintLine() {
    var v = $("#viewport");
    v.html('');
    $.each(data[cur_line].words, function (i, word_entry) {
            var word = word_entry.word;
            var elem = word_entry.elem ? word_entry.elem : $("<span>");
            word_entry.elem = elem;
            elem.text(word);
            paintWord(word_entry);
            v.append(elem);
            v.append(document.createTextNode(" "));
    });
}
function prevWord() {
    var repaint_line = false;
    var first = true;
    while (cur_line >= 0 || cur_word >= 0) {
        var word_entry = getCurrentWord();
        word_entry.status = S_PENDING;
        paintWord(word_entry);
        if (!first && word_entry.recognized && word_entry.goodStrokes.length) break;
        if (cur_line == 0 && cur_word == 0) break;
        if (cur_word == 0) {
            repaint_line = true;
            cur_line--;
            cur_word = data[cur_line].words.length - 1;
        } else {
            cur_word--;
        }
        var first = false;
    }
    if (repaint_line) {
        paintLine();
    }
    setupWord();
}
function nextWord(misstroke) {
    currentStroke = 1;
    answerGivenSoFar = "";
    $("#txtInput").val("");
    $("#prompt").text("");
    if (cur_word >= 0) {
        var word_entry = getCurrentWord();
        if (misstroke) {
            word_entry.status = S_INCORRECT;
        } else {
            word_entry.status = S_DONE;
        }
        paintWord(word_entry);
    }
    if (cur_word < data[cur_line].words.length - 1) {
        cur_word++;
    } else if (cur_line < data.length - 1) {
        cur_word = -1;
        cur_line++;
        paintLine();
        return nextWord();
    } else {
        // done
        finishExercise();
        return;
    }
    setupWord();
}

String.prototype.contains = function(it) { return this.indexOf(it) != -1; };

function diffSteno(actual, expected) {
    if (!actual) { // success we don't record
        return expected;
    }
    var actual_left = getLeftLettersFromSteno(actual);
    var expected_left = getLeftLettersFromSteno(expected);
    var actual_middle = getMiddleLettersFromSteno(actual);
    var expected_middle = getMiddleLettersFromSteno(expected);
    var actual_right = getRightLettersFromSteno(actual);
    var expected_right = getRightLettersFromSteno(expected);
    var r = "";
    function handler(a, e) {
        return function(i,l) {
            if (a.contains(l) && e.contains(l)) {
                r += l;
            } else if (!a.contains(l) && !e.contains(l)) {
            } else if (a.contains(l) && !e.contains(l)) {
                r += "<sub>" + l + "</sub>";
            } else if (!a.contains(l) && e.contains(l)) {
                r += "<sup>" + l + "</sup>";
            }
        }
    }
    $.each(["S","T","K","P","W","H","R"], handler(actual_left, expected_left));
    var old_r = r;
    $.each(["A", "O", "*", "E", "U"], handler(actual_middle, expected_middle));
    if (old_r == r) r += "-";
    $.each(["F","R","P","B","L","G","T","S","D","Z"], handler(actual_right, expected_right));
    return $("<span>").addClass("diff").html(r);
}

function finishExercise() {
    $("#txtInput").addClass("complete");
    $("#txtInput").prop("disabled", true);
    $("#prevbtn").prop("disabled", true);
    $("#nextbtn").prop("disabled", true);
    finished = true;
    // run some quick stats
    var errors = 0;
    var error_list = [];
    var v = $("#viewport");
    v.html("");
    $.each(data, function(i,line) {
            var d = $("<div class='many'>");
            $.each(line.words, function(j,word) {
                var cell = $("<table class='unit'>");
                cell.prop("title", word.user.join(", "))
                cell.append($("<tr>").html($("<td class='over'>").html(word.elem)));
                var annot = "";
                if (!word.recognized) {
                } else if (cur_mode == "speed") {
                    annot = diffSteno(word.user[word.user.length-1], word.bestStroke);
                } else if (cur_mode == "accuracy") {
                    // TODO: color code for victory
                    // two significant digits at all times
                    var time = word.time >= 1000 ? (Math.round(word.time / 100) / 10)
                                                 : (Math.round(word.time / 10) / 100);
                    annot += time;
                    if (word.user.length > 1) {
                        annot += "<sup class='errorCount'>(" + (word.user.length - 1) + ")</sup>"
                    }
                    annot = $("<span class='wordstat'>").html(annot);
                }
                cell.append($("<tr>").html($("<td class='under'>").html(annot)));
                d.append(cell);
                d.append(document.createTextNode(" "));
                if (word.status == S_INCORRECT) {
                    errors++;
                }
                });
            v.append(d);
            });
    $("#stats").html("<strong>Uncorrected errors:</strong> " + errors);
}

function setupWord() {
    var word_entry = getCurrentWord();
    var word = word_entry.word;
    if (!word_entry.goodStrokes.length) {
        return nextWord();
    }
    function strokeCompare(a,b) {
        return a.split("/").length - b.split("/").length;
    }
    function mungeStrokes(strokes) {
        return uniq(strokes).sort(strokeCompare).join(",");
    }
    currentDrillItem = {
        "Text": word,
        "GoodValue": mungeStrokes(word_entry.goodStrokes),
        "Value": mungeStrokes(word_entry.strokes),
    }
    paintWord(word_entry);
    word_entry.elem.addClass("current");
    if (cur_line != 0 || cur_word != 0) {
        stroke_start = new Date();
    }
}

function paintWord(word_entry) {
    var elem = word_entry.elem;
    elem.removeClass();
    if (!word_entry.recognized) {
        elem.addClass("nostroke");
    } else if (word_entry.status == S_DONE) {
        elem.addClass("done");
    } else if (word_entry.status == S_INCORRECT) {
        elem.addClass("incorrect");
    }
    // TODO: Add other colors which "hint" that the word is funny, e.g. if it is a brief
}

// ----------------------------------------------------------------------------
// Utility functions

function mapFilter(xs, f) {
    return xs.map(f).filter(function(x) {return x});
}

// Given list a of primitive items, returns it with duplicates removed.
function uniq(a) {
    var seen = {};
    return a.filter(function(item) {
        return seen.hasOwnProperty(item) ? false : (seen[item] = true);
    });
}

// Given to steno strokes, picks the 'better' one. We base this
// mostly on stroke size.
// TODO: have an expert look at this!
function take_best(s1, s2) {
    if (!s1) return s2;
    if (/\d/.test(s1)) { return s2; }
    if (/\d/.test(s2)) { return s1; }
    var l1 = s1.split("/").length;
    var l2 = s2.split("/").length;
    if (l1 < l2) { return s1; }
    else if (l2 < l1) { return s2; }
    // TODO: This doesn't make sense if we're not vowelizing
    if (s1.indexOf('*') == -1 && s2.indexOf('*') != -1) { return s1; }
    if (s2.indexOf('*') == -1 && s1.indexOf('*') != -1) { return s2; }
    if (s1.length < s2.length) { return s1; }
    if (s2.length < s1.length) { return s2; }
    return s1;
}

// ----------------------------------------------------------------------------
// QWERTY Steno support code

// Some of this code is pure, some relies on global state.
// Here are the variable declarations of the global state relied upon:

function showAnswerPrompt(steno) {
    streak = 0;
    if (!stroke_start) {
        // first one's free.
        stroke_start = new Date();
        return;
    }
    misstrokes++;
    var we = getCurrentWord();
    we.user.push(steno);
    var cands = currentDrillItem.
        GoodValue.
        split(",").
        filter(function(v){return v.indexOf(answerGivenSoFar) == 0}).
        map(function(v) {return v.substring(answerGivenSoFar.length)});
    // PROBLEM: want to figure out what LIKELY candidate was
    addSample(steno, cands);
    if (cur_mode == "speed") {
        nextWord(true);
    }
    $("#prompt").text(bestStroke(cands) + ", you did " + steno);
}
function setStenoKeyboardPressedKeys() {}
function clearStenoKeyboardPressed() {}
function hideAnswerPrompt() {}
function showWpm() {}
function setNextDrillItem(steno) {
    addSample(steno, [steno]);
    var we = getCurrentWord();
    we.user.push(steno);
    if (!stroke_start) stroke_start = new Date();
    we.time = (new Date()).getTime() - stroke_start.getTime();
    streak++;
    if (streak > best_streak) best_streak = streak;
    nextWord();
}
function possibleAnswerClick() {
}
function showDrillItem() {}
// Here is the library code.

var currentTdAnswer = 0;
var itemsAnswered = 0;
var keysUp = [], keysDown = [];
var currentDrillItem;
var answerGivenSoFar = "";
var currentStroke = 1;

function correctAnswer(answer) {
    if (jQuery('#chkPlainTextInput').is(':checked')) {

        // Plain text mode
        var text = currentDrillItem.Text;

        if (text.toLowerCase() == answer.toLowerCase()) {

            return 0;
        }
    }
    else {
        // Steno mode
        var correctAnswersString = currentDrillItem.Value;

        var correctAnswersArray = correctAnswersString.split(",");

        for (var i = 0; i < correctAnswersArray.length; i++) {

            // If this possible answer starts with the same strokes as the user has given
            if (correctAnswersArray[i].indexOf(answerGivenSoFar) == 0) {

                var strokes = correctAnswersArray[i].split("/");

                var correctStroke = strokes[currentStroke - 1];

                if (answer == correctStroke) {

                    // Correct stroke
                    answerGivenSoFar += answer + "/"

                    var strokesRemaining = strokes.length - currentStroke;

                    return strokesRemaining;
                }
            }
        }
    }

    // Not a correct stroke
    return -1;
}

function getMiddleLettersFromSteno(steno) {
    var index = steno.indexOf("-");

    if (index >= 0) {
        // no vowels
        return "";
    }
    var r = "";

    if (steno.indexOf("A") >= 0) {
        r += "A";
    }

    if (steno.indexOf("O") >= 0) {
        r += "O";
    }

    if (steno.indexOf("*") >= 0) {
        r += "*";
    }

    if (steno.indexOf("E") >= 0) {
        r += "E";
    }

    if (steno.indexOf("U") >= 0) {
        r += "U";
    }
    return r;
}

function getLeftLettersFromSteno(steno) {
    
    var index = steno.indexOf("-");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("A");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("O");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("*");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("E");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }
    
    index = steno.indexOf("U");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    return steno;
}

function getRightLettersFromSteno(steno) {
    
    var index = steno.indexOf("-");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("U");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("E");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("*");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("O");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("A");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    return "";
}

function clearKeys() {
    
    keysDown = [];
    keysUp = [];
}

function addKeyDown(letter) {

    if (letter != null) {

        if (jQuery.inArray(letter, keysDown) == -1) {

            keysDown.push(letter);

            setStenoKeyboardPressedKeys(keysDown);
        }
    }
}

function addKeyUp(letter) {

    if (letter != null) {

        if (jQuery.inArray(letter, keysUp) == -1) {

            keysUp.push(letter);
        }
    }
}

function getStenoFromLetterArray(letters) {

    var leftLetters = [];
    var rightLetters = [];
    var middleLetters = [];

    for (var i = 0; i < letters.length; i++) {

        var singleLetter = letters[i];

        var indexOfDash = singleLetter.indexOf("-");

        if (indexOfDash == 0) {

            // Key is on the right
            rightLetters.push(singleLetter[1]);
        }
        else if (indexOfDash == 1) {

            // Key is on the left
            leftLetters.push(singleLetter[0]);
        }
        else if (singleLetter == '#') {

            // Number Bar
            leftLetters.push(singleLetter);
        }
        else {
            // Middle key
            middleLetters.push(singleLetter);
        }
    }

    if (middleLetters.length == 0 && rightLetters.length > 0) {

        middleLetters.push("-");
    }

    var leftString = "";
    var rightString = "";
    var middleString = "";

    leftString = orderLeftStenoLetters(leftLetters);
    rightString = orderRightStenoLetters(rightLetters);
    middleString = orderMiddleStenoLetters(middleLetters);

    return leftString + middleString + rightString;
}

function orderLeftStenoLetters(leftLetters) {

    var result = "";

    result += getLetterFromArray("#", leftLetters);
    result += getLetterFromArray("S", leftLetters);
    result += getLetterFromArray("T", leftLetters);
    result += getLetterFromArray("K", leftLetters);
    result += getLetterFromArray("P", leftLetters);
    result += getLetterFromArray("W", leftLetters);
    result += getLetterFromArray("H", leftLetters);
    result += getLetterFromArray("R", leftLetters);

    return result;
}

function orderRightStenoLetters(rightLetters) {

    var result = "";

    result += getLetterFromArray("F", rightLetters);
    result += getLetterFromArray("R", rightLetters);
    result += getLetterFromArray("P", rightLetters);
    result += getLetterFromArray("B", rightLetters);
    result += getLetterFromArray("L", rightLetters);
    result += getLetterFromArray("G", rightLetters);
    result += getLetterFromArray("T", rightLetters);
    result += getLetterFromArray("S", rightLetters);
    result += getLetterFromArray("D", rightLetters);
    result += getLetterFromArray("Z", rightLetters);

    return result;
}

function orderMiddleStenoLetters(middleLetters) {

    var result = "";

    result += getLetterFromArray("A", middleLetters);
    result += getLetterFromArray("O", middleLetters);
    result += getLetterFromArray("*", middleLetters);
    result += getLetterFromArray("E", middleLetters);
    result += getLetterFromArray("U", middleLetters);
    result += getLetterFromArray("-", middleLetters);

    return result;
}

function getLetterFromArray(singleLetter, letterArray) {

    var result = "";

    if (jQuery.inArray(singleLetter, letterArray) > -1) {

        result += singleLetter;
    }

    return result;
}

function getStenoLetter(keyCode) {

    var result = null;

    if (keyCode == 65 || keyCode == 81) {

        result = "S-";
    }
    else if (keyCode == 87) {

        result = "T-";
    }
    else if (keyCode == 83) {

        result = "K-";
    }
    else if (keyCode == 69) {

        result = "P-";
    }
    else if (keyCode == 68) {

        result = "W-";
    }
    else if (keyCode == 82) {

        result = "H-";
    }
    else if (keyCode == 70) {

        result = "R-";
    }
    else if (keyCode == 84 || keyCode == 89 || keyCode == 71 || keyCode == 72) {

        result = "*";
    }
    else if (keyCode == 67) {

        result = "A";
    }
    else if (keyCode == 86) {

        result = "O";
    }
    else if (keyCode == 78) {

        result = "E";
    }
    else if (keyCode == 77) {

        result = "U";
    }
    else if (keyCode == 85) {

        result = "-F";
    }
    else if (keyCode == 74) {

        result = "-R";
    }
    else if (keyCode == 73) {

        result = "-P";
    }
    else if (keyCode == 75) {

        result = "-B";
    }
    else if (keyCode == 79) {

        result = "-L";
    }
    else if (keyCode == 76) {

        result = "-G";
    }
    else if (keyCode == 80) {

        result = "-T";
    }
    else if (keyCode == 186 || keyCode == 59) {

        result = "-S";
    }
    else if (keyCode == 219) {

        result = "-D";
    }
    else if (keyCode == 192 || keyCode == 222) {

        result = "-Z";
    }
    else if (keyCode >= 48 && keyCode <= 57) {

        result = "#";
    }
    else if (keyCode == 189) {

        result = "#";
    }

    return result;
}

function keyDown(event) {

    if (jQuery('#chkPlainTextInput').is(':checked')) {
        
        // Plain text mode
    }
    else {
        // Steno mode
        event.preventDefault();

        addKeyDown(getStenoLetter(event.keyCode));
    }
}

function keyUp(event) {

    if (jQuery('#chkPlainTextInput').is(':checked')) {

        // Plain text mode
        var text = jQuery('#txtInput').val();

        text = jQuery.trim(text);

        var remainingStrokes = correctAnswer(text);

        if (remainingStrokes == 0) {

            // Correct
            // Entire answer complete, no more remaining strokes
            itemsAnswered++;

            hideAnswerPrompt();

            showWpm();

            setNextDrillItem();

            showDrillItem();

            jQuery('#txtInput').val('');
        }
    }
    else {
        event.preventDefault();

        addKeyUp(getStenoLetter(event.keyCode));

        if (keysUp.length == keysDown.length) {

            // All keys up
            clearStenoKeyboardPressed();

            var steno = getStenoFromLetterArray(keysDown);

            if (steno != "") {

                if (steno != "*") {

                    var remainingStrokes = correctAnswer(steno);

                    if (remainingStrokes == 0) {

                        // Correct stroke
                        // Entire answer complete, no more remaining strokes
                        itemsAnswered++;

                        hideAnswerPrompt();

                        showWpm();

                        setNextDrillItem(steno); // XXX NEW XXX

                        showDrillItem();
                    }
                    else if (remainingStrokes > 0) {

                        // Correct stroke
                        // There are more strokes remaining
                        currentStroke++;

                        jQuery('#txtInput').val(answerGivenSoFar);

                        possibleAnswerClick(currentTdAnswer + 1);
                    }
                    else {
                        // Incorrect stroke
                        showAnswerPrompt(steno);
                    }
                }
                else {
                    // Asterisk key
                    // Delete last stroke
                    if (answerGivenSoFar.length > 0) {

                        currentStroke--;

                        var answerSoFarWithoutSlash = answerGivenSoFar.substring(answerGivenSoFar.length - 1, 1);

                        var indexOfLastSlash = answerSoFarWithoutSlash.lastIndexOf("/");

                        if (indexOfLastSlash < 0) {
                            answerGivenSoFar = "";
                        }
                        else {
                            answerGivenSoFar = answerSoFarWithoutSlash.substring(0, indexOfLastSlash);
                        }

                        jQuery('#txtInput').val(answerGivenSoFar);

                        possibleAnswerClick(currentTdAnswer + 1);
                    } else {
                        if (cur_mode == "speed") {
                            prevWord(); // XXX NEW XXX
                        }
                    }
                }
            }

            clearKeys();
        }
    }
}

</script>
</body>
</html>
