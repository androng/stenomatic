<!--

Things I know how to implement:

    * Generate a heat map of words you got wrong from the
      transcript.

    * Generate a heat map of how long it took to do the words

    * If we can guess what the "right" stroke which was supposed
      to be used (reasonable for simplified test sets), we can
      collect per key and chord statistics (which keys do you get
      wrong)

    * Aggregated data: if you do the same test set multiple times,
      give some ability to track progress over time.

    * Karaoke mode: take a cue file and do time trials. (Need to
      give user a grace period since the subfiles will not necessarily
      be the right place.) Use YOUTUBE to source music cheaply.

    * Time trial mode: karaoke mode but without the karaoke

This is like, a non-gameified version of many of the minigames
imagined in http://plover.stenoknight.com/2011/04/hover-plover.html

Bugs:

    * Partial strokes UI is pretty confusing.  Can we chunk up the
      words somehow to give partial progress?  Seems algorithmically tricky.

-->
<html>
<head>
<title>Stenomatic 9000</title>
<link rel="prefetch" href="dict.json">
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<style>
#viewport { font-size: 2em; }
.brief {color: blue;}
.nostroke {color: purple;}
.done {color: grey !important;}
.current {background:#DDD}
.complete {background:#9F9}
.incorrect {color: #F99 !important;}
#chkPlainTextInput {display: none}
.boxLabel {margin-right:1em;}
h2 {font-size:1.2em;}
td {vertical-align: top;}
.many {margin-left:2em;text-indent:-2em;}
</style>
</head>
<body>
<div id="viewport"><em>Loading Dictionary...</em></div>
<div>
<input type="text" id="txtInput">
<input type="submit" value="&lt;" id="prevbtn">
<input type="submit" value="&gt;" id="nextbtn">
<input type="submit" value="Reload" id="loadbtn2">
</div>
<div id="barometer"></div>
<div id="stats"></div>
<span id="prompt"></span>
<input type="checkbox" id="chkPlainTextInput">
<hr>
<p>
<em>Greetings mortal, I am the Stenomatic 9000</em>. To utilize my services, copy paste some exercise material (for example, the exercises in <a href="https://sites.google.com/site/ploverdoc/lesson-1-fingers-and-keys">Learn Plover</a>) and select what kind of exercise you want to do.  Then press load and go! (If you change any settings, you will need to reload the exercise.)  I am a derivative work of <a href="http://qwertysteno.com/Home/">Qwerty Steno</a>, with whom I share the QWERTY input handling code.
</p>
<h2>Mode:</h2>
<table id="modebtns">
    <tr>
        <td><input type="radio" name="mode" value="accuracy" onclick="updateMode()" checked></td>
        <td><strong class="boxLabel">Accuracy</strong> If you misstroke, the stroke is rejected; you cannot move on until you get the stroke right.</td>
    </tr>
    <tr>
        <td><input type="radio" name="mode" value="speed" onclick="updateMode()"></td>
        <td><strong class="boxLabel">Speed</strong> If you misstroke a word, you'll move onto the next one.</td>
    </tr>
</table>
<h2>Style:</h2>
<table id="stylebtns">
    <tr>
        <td><input type="radio" name="style" value="script" checked></td>
        <td><strong class="boxLabel">Script</strong> Follow the script in the source order.</td>
    </tr>
    <tr>
        <td><input type="radio" name="style" value="randomized"></td>
        <td><strong class="boxLabel">Randomized</strong> Generate <input type="text" id="randomLength" value="100" size="1"> random words sampled from the source input (weighted based on occurrence frequency).</td>
    </tr>
</table>
<h2>Difficulty:</h2>
You can reduce the difficulty of exercises by practicing only subsets of the Steno keyboard. <input type="submit" value="Enable all" onclick="$('#difficultybtns input').prop('checked', true);" /> <input type="submit" value="Clear all" onclick="$('#difficultybtns input').prop('checked', false);" />
<table id="difficultybtns">
    <tr>
        <td><input type="checkbox" id="enable-left" value="left" checked></td>
        <td><strong class="boxLabel">Left hand keys</strong> (STKPWHR)
        </td>
    </tr>
    <tr>
        <td><input type="checkbox" id="enable-vowels" value="vowel" checked></td>
        <td><strong class="boxLabel">Vowel keys</strong> (AOEU)
        </td>
    </tr>
    <tr>
        <td><input type="checkbox" id="enable-asterisk" value="asterisk" checked></td>
        <td><strong class="boxLabel">Asterisk</strong> If this is unchecked, words which must be disambiguated with an asterisk will not be given.
        </td>
    </tr>
    <tr>
        <td><input type="checkbox" id="enable-right" value="right" checked></td>
        <td><strong class="boxLabel">Right hand</strong> (FRPBLGTSDZ)
        </td>
    </tr>
    <tr>
        <td><input type="checkbox" id="enable-multistroke" value="multistroke" checked></td>
        <td><strong class="boxLabel">Multi-stroke</strong> If this is unchecked, only the first stroke of multi-stroke words will be tested.
        </td>
    </tr>
</table>
<input type="submit" value="Clear" id="clearbtn">
<input type="submit" value="Load" id="loadbtn">
<select id="select-sample"><option value="data">(Preloaded data)</option></select>
        <div><textarea id="data" cols="80" rows="20">
The quick brown fox jumps over the lazy dog.
Pack my box with five dozen liquor jugs.
</textarea>
<div style="display:none;" id="samples">
    <textarea id="learnplover-1-left" name="[Learn Plover] 1. One-Syllable Words (Left)">
    'sap' 'sag' 'sat' 'sass' 'sad' 'sop' 'sob' 'sell' 'set' 'says'
    'tar' 'tap' 'tab' 'tag' 'tad' 'tour' 'top' 'toll' 'tell' 'tough' 'tub' 'tug'
    'car' 'cap' 'cab' 'cat' 'cad' 'core' 'cop' 'cog' 'cot' 'cod' 'keg' 'cuff' 'cur' 'cup' 'cub' 'cull' 'cut' 'cuss'
    'pal' 'pat' 'pass' 'pad' 'pour' 'poll' 'pot' 'pod' 'pep' 'peg' 'pet' 'puff' 'pup' 'pub' 'pull' 'pug' 'put' 'pus'
    'war' 'wag' 'wad' 'was' 'wore' 'web' 'well' 'wet' 'wed'
    'half' 'hag' 'hat' 'had' 'has' 'hop' 'hog' 'hot' 'her' 'hell' 'head' 'huff' 'hub' 'hull' 'hug' 'hut'
    'rap' 'rag' 'rat' 'roar' 'rob' 'roll' 'rot' 'rod' 'red' 'rough' 'rub' 'rug' 'rut'
    </textarea>
    <textarea id="learnplover-1-right" name="[Learn Plover] 1. One-Syllable Words (Right)">
    'half' 'tough' 'cuff' 'puff' 'huff' 'rough'
    'tar' 'car' 'war' 'tour' 'core' 'pour' 'wore' 'roar' 'her' 'cur' 
    'sap' 'tap' 'cap' 'rap' 'sop' 'top' 'cop' 'hop' 'pep' 'cup' 'pup'
    'tab' 'cab' 'sob' 'rob' 'web' 'tub' 'cub' 'pub' 'rub'
    'pal' 'toll' 'poll' 'roll' 'sell' 'tell' 'well' 'hell' 'cull' 'pull' 'hull'
    'sag' 'tag' 'wag' 'hag' 'rag' 'cog' 'hog' 'keg' 'peg' 'tug' 'pug' 'hug' 'rug'
    'sat' 'cat' 'pat' 'hat' 'rat' 'cot' 'pot' 'hot' 'rot' 'set' 'pet' 'wet' 'cut' 'put' 'hut' 'rut'
    'sass' 'pass' 'cuss' 'pus'
    'sad' 'tad' 'cad' 'pad' 'wad' 'had' 'cod' 'pod' 'wed' 'head' 'red'
    'has' 'says' 'was'
    </textarea>
    <textarea id="learnplover-3a-1" name="[Learn Plover] 3A-1. The Fifth Vowel Key">
    'still', 'rig', 'hit', 'sip'
    'sir', 'skirt'
    'crypt', 'syrup'
    'pig' 'rift' 'scribble' 'rid' 'river'
    'hid' 'wilt' 'wig' 'wit' 'spill'
    </textarea>
    <textarea id="learnplover-3a-2" name="[Learn Plover] 3A-2. Long Vowel Chords">
    'aids' 'ace' 'ate' 'able' 'ape' 'raid' 'raise' 'rail' 'rate' 'pay' 'paid' 'pace' 'tape' 'spray' 'praise'
    'weaver' 'trees' 'eel' 'eat' 'evil' 'ear' 'heat' 'heap' 'wield' 'weird' 'peer' 'priest' 'tree' 'tweeze' 'tweed' 'seat' 'cease' 'seed' 'seize' 'secrete'
    'ire' 'I'll' 'ice' 'rife' 'ripe' 'right' 'height' 'wild' 'pipe' 'pride' 'prize' 'kite' 'type' 'spite' 'drive'
    'hope' 'spore' 'post' 'sold' 'prose' 'ode' 'oat' 'over' 'robe' 'rope' 'roar' 'rove' 'host' 'wove' 'wrote' 'pole' 'pose' 'cope' 'coat' 'code' 'crow' 'told'
    'cube' 'use' 'rude' 'rule' 'pure' 'prude' 'Proust' 'cure' 'cruel' 'crude' 'cruise' 'truce' 'truth' 'spew' 'skew'
    </textarea>
    <textarea id="learnplover-3a-3" name="[Learn Plover] 3A-3. Dipthongs">
    'all' 'awful' 'raw' 'call' 'caught' 'crawl' 'sprawl' 'scald' 'straw' 'halt' 'hall' 'wall'
    'out' 'how' 'howl' 'house' 'pout' 'power' 'prowl' 'tower' 'spouse' 'sprout' 'scour'
    'soy' 'oil' 'coil' 'toil' 'soil'
    </textarea>
    <textarea id="learnplover-3a-4" name="[Learn Plover] 3A-4. Vowel Disambiguator Chords">
    'wheel' 'wheal' 'read' 'reed' 'reel' 'real' 'heel' 'heal' 'hear' 'here' 'ware' 'wear' 'pea' 'pee' 'peace' 'piece' 'tee' 'tea' 'sea' 'see'
    'tail' 'tale' 'sale' 'sail' 'stare' 'stair' 'waist' 'waste'
    'hood' 'rude' 'pool' 'crew' 'soot' 'truce' 'school' 'ruse'
    'road' 'rode' 'roar' 'toad' 'soar' 'sore'
    </textarea>
    <textarea id="learnplover-3b" name="[Learn Plover] 3B. The Missing Keys">
    'due' 'duffer' 'deferral' 'devil' 'double' 'drug' 'depress' 'desire' 'dessert' 'destroyed'
    'feral' 'ford' 'for' 'phrase' 'fierce' 'fable' 'feeble' 'sphere' 'fries'
    'leader' 'lace' 'letter' 'lust' 'lovers'
    'glad' 'glare' 'glides' 'give' 'get' 'group' 'guest' 'guide' 'gravel' 'cigarette' 'goblet'
    'bored' 'board' 'bruise' 'buyer' 'bobble' 'brutal'
    'zest' 'zap' 'zag'
    'vile' 'vase' 'virus'
    'eke' 'rockets' 'correct' 'quake' 'task'
    </textarea>
    <textarea id="learnplover-3c" name="[Learn Plover] 3C. The Remaining Single Letters">
    'nag' 'nap' 'nab' 'nut' 'never' 'nestle' 'nod' 'nest' 'nerd'
    'pent' 'parent' 'went' 'earns' 'rant' 'hunt' 'hand' 'panel' 'stun'
    'must' 'muffle' 'maggot' 'mallet' 'smuggle' 'morals'
    'arm' 'rum' 'harm' 'tempt' 'term'
    'calmed' 'palm' 'qualms'
    'jut' 'jug' 'just' 'jest' 'jets' 'job' 'jostle' 'jazz' 'jagged'
    'urge' 'edge' 'average' 'purge' 'trudge' 'storage'
    'yard' 'yet' 'yacht' 'yurt'
    </textarea>
    <textarea id="learnplover-3c-cumulative" name="[Learn Plover] 3C. Including Sounds From Previous Lessons">
    'noun' 'inhibit' 'nudge' 'notes' 'knack' 'enacts' 'neck' 'known' 'knock' 'gnome' 'noise' 'novice' 'named' 'neural' 'snide' 'announce'
    'loin' 'donor' 'winner' 'dinner' 'learned' 'lend' 'allowance' 'flaunt' 'deference' 'different' 'dance' 'diner' 'demand' 'grunt' 'grant' 'gleans' 'severance' 'cement' 'design'
    'mound' 'mourn' 'maim' 'matter' 'commit' 'commend' 'smudge' 'smuggle' 'semester'
    'forms' 'primed' 'serum' 'time' 'hermit' 'maim' 'plumb' 'dream' 'gym' 'germ' 'jam' 'blame' 'bottom' 'grammar'
    'balm' 'psalm'
    'judge' 'journal' 'join' 'joyful' 'jam' 'gerunds'
    'forge' 'budgets' 'average' 'leverage' 'merge' 'beige' 'carriage' 'fidget' 'frigid' 'digit' 'gadget' 'garage' 'grudge' 'turgid'
    'year' 'yearn' 'yolk'
    </textarea>
    <textarea id="learnplover-3d" name="[Learn Plover] 3D. Digraphs">
    'thefts' 'thud' 'thus' 'thug'
    'hath' 'earth' 'oath' 'health' 'wealth' 'worth' 'path' 'troth'
    'chess' 'chest' 'chart' 'chat' 'chop' 'chore' 'chaff'
    'touch' 'etch' 'ratchet' 'hutch' 'hatch' 'watch' 'patch' 'catch' 'crutch' 'such' 'sketch' 'stretch' 'retch'
    'shell' 'shuffled' 'shall' 
    'ash' 'rush' 'rash' 'hush' 'hash' 'wash' 'push' 'posh' 'crush' 'crash' 'trash' 'squash' 'stash'
    'anger' 'storing' 'rung' 'rang' 'prong' 'tongue' 'twang' 'song' 'stung' 'strong'
    'sponge' 'orange' 
    </textarea>
    <textarea id="learnplover-3d-cumulative" name="[Learn Plover] 3D. Including Sounds From Previous Lessons">
    'thing' 'thence' 'them' 'thumb' 'thrill' 'throng' 'thrash'
    'seethe' 'method' 'math' 'birth' 'breath' 'fifth' 'death' 'sleuth' 'blithe' 'growth'
    'choose' 'chasm' 'chuck' 'check' 'churn' 'cherub' 'chin' 'channel' 'chant' 'chance' 'chive' 'charm'
    'bleach' 'much' 'latch' 'leech' 'match' 'botch' 'fetch' 'ditch' 'glitch' 'vouch' 'slouch' 'smooch' 'splotch'
    'shim' 'slime' 'shrewd' 'shrine' 'shuck' 'shark' 'shock' 'sheesh' 'shrivel' 'sugar'
    'lash' 'mesh' 'mash' 'plush' 'bush' 'brush' 'fish' 'fresh' 'flush' 'flesh' 'flash' 'dash' 'delish' 'gosh' 'gash' 'shush' 'slash' 'smush' 'slosh' 'splash' 'squish' 'Irish'
    'anger' 'finger' 'dung' 'lung' 'ping' 'pong' 'among' 'bring' 'young' 'fang' 'flung' 'gang' 'belong'
    'change' 'range' 'hinge' 'lounge' 'plunge' 'cringe' 'tinge' 'fringe' 'derange' 'grunge' 'syringe'
    </textarea>
    <textarea id="learnplover-3e" name="[Learn Plover] 3E. Common Compound Clusters">
    'hemp' 'trump' 'rump' 'romp' 'ramp' 'pump' 'camp' 'cramp' 'tamp' 'pomp'
    'curve' 'carve' 'serve' 'swerve' 'starve' 
    'squelch'
    'hulk' 'calc' 'sulk' 'talc'
    'rank' 'honk' 'wonk' 'prank' 'crank' 'tank'
    'session' 'option' 'ration' 'portion' 'passion' 'cushion' 'caption' 'suppression'
    'section' 'correction' 'suction'
    'arch' 'ranch' 'hunch' 'porch' 'crunch' 'quench' 'torch' 'trench' 'stench' 'starch' 
    </textarea>
    <textarea id="learnplover-3e-cumulative" name="[Learn Plover] 3E. Including Sounds From Previous Lessons">
    'limp' 'blimp' 'chomp' 'clamp' 'damp' 'slump' 'shrimp' 'jump'
    'nerve' 'verve' 'marvel'
    'village' 'mulch' 'bulge' 'belch' 'bilge' 'gulch' 'pillage'
    'ilk' 'milk' 'bulk' 'silk' 'bilk'
    'wink' 'mink' 'plank' 'brink' 'blink' 'blank' 'flank' 'flunk' 'dank' 'drink' 'gunk' 'junk' 'link' 'chunk'
    'lesion' 'provision' 'fusion' 'lotion' 'operation' 'mission' 'motion' 'pollution'
    'election' 'auction' 'correction' 'collection' 'fraction' 'friction' 'depiction' 'selection' 'seduction'
    'finch' 'clench' 'branch' 'march' 'lurch' 'lynch' 'birch' 'brunch' 'church' 'drench'
    </textarea>
</div></div>
<script>
// ----------------------------------------------------------------------------
// Dictionary initialization
var rdata = {"i": ["EU"]};
$.getJSON("dict.json", function(dict) {
        $.each( dict, function(k,rv) {
            if (/\d/.test(k)) return;
            var v = rv.toLowerCase();
            if (rdata.hasOwnProperty(v)) { // watch
                rdata[v].push(k);
            } else {
                rdata[v] = [k];
            }
            });
        init();
        });

function depunctuateWord(rword) {
    return rword.replace(/[!"#$%&\\\(\)*+,-.\/:;<=>?@\[\]\^_`{|}~]/g, "").replace(/^'/, "").replace(/'$/, "");
}
function cleanWord(rword) {
    return depunctuateWord(rword).toLowerCase();
}
function wordStrokes(word) {
    var r = rdata[cleanWord(word)];
    return r ? r : [];
}
function bestStroke(strokes) {
    var cand;
    $.each(strokes, function(i, s) {
            cand = take_best(cand, s);
            });
    return cand;
}
function filterDifficulty(stroke) {
    var strokes = stroke.split("/");
    var r = [];
    for (var i = 0; i < strokes.length; i++) {
        if (!$("#enable-asterisk").prop("checked") && strokes[i].indexOf("*") != -1) return false;
        var leftLetters = "", rightLetters = "", middleLetters = "";
        if ($("#enable-left").prop("checked")) { leftLetters = getLeftLettersFromSteno(strokes[i]); }
        if ($("#enable-vowels").prop("checked")) { middleLetters = getMiddleLettersFromSteno(strokes[i]); }
        if ($("#enable-right").prop("checked")) { rightLetters = getRightLettersFromSteno(strokes[i]); }
        if (middleLetters.length == 0 && rightLetters.length > 0) { middleLetters = "-"; }
        r.push(leftLetters + middleLetters + rightLetters);
        if (!$("#enable-multistroke").prop("checked")) {
            break;
        }
    }
    return r.join("/");
    //var steno = stroke.split('/')[0];
}
// TODO: lift "chordifying" code from https://plover.goeswhere.com/
// so we can get per-chord stats

// ----------------------------------------------------------------------------
// Main user interface
// data is a list of {index: wordcount index, words: list of {word: word}}
var data, cur_line, cur_word;
var currentStroke = 1;
var cur_mode, cur_style;
var samples; // {time: Date, start_time: Date, expected_strokes: [String], actual_stroke: String, line: Number, word: Number}
var stroke_start, exercise_start;
var streak = 0;
var best_streak = 0;
var misstrokes = 0;
var finished = false;

function updateMode() {
    cur_mode = $('input[name=mode]:checked', '#modebtns').val();
}

function updateDifficulty() {
    // cur_difficulty = [$("#enable-vowels").val(), $("#enable-left").val(), $("#enable-right").val(), $("#enable-asterisk").val()];
}

function updateStyle() {
    cur_style = $('input[name=style]:checked', '#stylebtns').val();
}

function updateBarometer() {
    if (!exercise_start) {
        exercise_start = new Date();
    }
    var wpm = Math.round((1000 * 60 * (data[cur_line].index + cur_word)) / ((new Date()).getTime() - exercise_start.getTime()));
    if (wpm > 300) { wpm = 300; }
    // ToDo: WPM is not really right, but doing it this way
    // so that the easier difficulty modes are not completely
    // bogus
    $('#barometer').html("[" + (cur_line + 1) + "/" + data.length + "] <strong>WPM:</strong> " + wpm + ", <strong>Streak:</strong> " + streak + " (best: " + best_streak + "), <strong>Misstrokes:</strong> " + misstrokes);
}

// hmm, I don't know what to actually do with this data
function addSample(actual, expecteds) {
    /*
    samples.push({time: new Date(),
                  start_time: stroke_start,
                  actual_stroke: actual,
                  expected_strokes: expecteds,
                  line: cur_line,
                  word: cur_word});
                  */
    updateBarometer();
}

function init() {
    $("textarea", "#samples").each(function() {
            $("#select-sample").append($("<option>").prop("value", $(this).prop("id")).text($(this).prop("name")));
            });
    $("#select-sample").change(function(e) {
            var t = $(document.getElementById($("#select-sample").val()));
            $("#data").val(t.val());
            });
    $("#txtInput").val(""); // force empty
    $("#loadbtn").click(loadData);
    $("#loadbtn2").click(loadData);
    $("#clearbtn").click(function() {$("#data").val("")});
    $("#txtInput").keyup(keyUp).keydown(keyDown);
    $("#prevbtn").click(function() {
            if (cur_line == 0) {
                cur_word = -1;
                $.each(data[cur_line].words, function(j,word_entry) {
                        word_entry.status = S_PENDING;
                    });
                paintLine();
                nextWord();
                return;
            }
            var i = 1;
            var old_cur_line = cur_line;
            while (cur_line >= old_cur_line && cur_line - i >= 0) {
                cur_line -= i;
                $.each(data[cur_line].words, function(j,word_entry) {
                        word_entry.status = S_PENDING;
                    });
                cur_word = -1;
                paintLine();
                nextWord();
                i++;
            }
        });
    $("#nextbtn").click(function() {
        if (cur_line == data.length - 1) return;
        cur_line++;
        cur_word = -1;
        paintLine();
        nextWord();
        });
    loadData();
    updateMode();
}
var S_PENDING = 0;
var S_INCORRECT = 1;
var S_DONE = 2;
function copyExerciseWord(word_entry) {
    return {word: word_entry.word,
        strokes: word_entry.strokes,
        recognized: word_entry.recognized,
        status: word_entry.status
    }
}
function mkExerciseWord(word, strokes, recognized) {
    return {word: word,
        strokes: strokes,
        recognized: recognized,
        status: S_PENDING};
}
function loadData() {
    data = [];
    var text = $("#data").val();
    var lines = text.split("\n");
    var c = 0;
    updateStyle();
    updateDifficulty();
    if (cur_style == "script") {
        $.each( lines, function(i,line) {
                var cur = [];
                var sub_c = 0;
                var words = line.split(" ");
                $.each( words, function(i,word) {
                    if (/\S/.test(word)) {
                        var strokes = wordStrokes(word);
                        var t_strokes = mapFilter(strokes, filterDifficulty);
                        if (t_strokes) {
                            sub_c++;
                        }
                        cur.push(mkExerciseWord(word, t_strokes, !!strokes.length));
                    }
                    });
                if (cur.length > 0) data.push({index: c, words: cur});
                c += sub_c;
                });
    } else {
        var count = parseInt($("#randomLength").val());
        var corpus = [];
        $.each( lines, function(i,line) {
                var words = line.split(" ");
                $.each( words, function(i, rword) {
                    var word = depunctuateWord(rword);
                    var t_strokes = mapFilter(wordStrokes(word), filterDifficulty);
                    if (/\S/.test(word) && t_strokes) {
                        corpus.push(mkExerciseWord(word, t_strokes, true));
                    }
                    });
                });
        var cur = [];
        for (var i = 0; i < count; i++) {
            if (i % 8 == 0) {
                cur = [];
                data.push({index: i, words: cur});
            }
            cur.push(copyExerciseWord(corpus[Math.floor(Math.random() * corpus.length)]));
        }
    }
    if (data.length) startData();
}
function startData() {
    cur_line = 0;
    cur_word = -1;
    exercise_start = false;
    samples = [];
    streak = 0;
    best_streak = 0;
    misstrokes = 0;
    $("#txtInput").removeClass("complete");
    $("#txtInput").prop("disabled", false);
    $("#prevbtn").prop("disabled", false);
    $("#nextbtn").prop("disabled", false);
    finished = false;
    $('#stats').html("");
    $('#barometer').html("");
    paintLine();
    nextWord();
}
function paintLine() {
    var v = $("#viewport");
    v.html('');
    $.each(data[cur_line].words, function (i, word_entry) {
            var word = word_entry.word;
            var elem = word_entry.elem ? word_entry.elem : $("<span>");
            word_entry.elem = elem;
            elem.text(word);
            paintWord(word_entry);
            v.append(elem);
            v.append(document.createTextNode(" "));
    });
}
function prevWord() {
    var repaint_line = false;
    var first = true;
    while (cur_line >= 0 || cur_word >= 0) {
        var word_entry = data[cur_line].words[cur_word];
        word_entry.status = S_PENDING;
        paintWord(word_entry);
        if (!first && word_entry.recognized && word_entry.strokes.length) break;
        if (cur_line == 0 && cur_word == 0) break;
        if (cur_word == 0) {
            repaint_line = true;
            cur_line--;
            cur_word = data[cur_line].words.length - 1;
        } else {
            cur_word--;
        }
        var first = false;
    }
    if (repaint_line) {
        paintLine();
    }
    setupWord();
}
function nextWord(misstroke) {
    currentStroke = 1;
    answerGivenSoFar = "";
    $("#txtInput").val("");
    $("#prompt").text("");
    if (cur_word >= 0) {
        var word_entry = data[cur_line].words[cur_word];
        if (misstroke) {
            word_entry.status = S_INCORRECT;
        } else {
            word_entry.status = S_DONE;
        }
        paintWord(word_entry);
    }
    if (cur_word < data[cur_line].words.length - 1) {
        cur_word++;
    } else if (cur_line < data.length - 1) {
        cur_word = -1;
        cur_line++;
        paintLine();
        return nextWord();
    } else {
        // done
        $("#txtInput").addClass("complete");
        $("#txtInput").prop("disabled", true);
        $("#prevbtn").prop("disabled", true);
        $("#nextbtn").prop("disabled", true);
        finished = true;
        // run some quick stats
        var errors = 0;
        var error_list = [];
        var v = $("#viewport");
        v.html("");
        $.each(data, function(i,line) {
                var d = $("<div class='many'>");
                $.each(line.words, function(j,word) {
                    d.append(word.elem);
                    d.append(document.createTextNode(" "));
                    if (word.status == S_INCORRECT) {
                        errors++;
                    }
                    });
                v.append(d);
                });
        $("#stats").html("<strong>Uncorrected errors:</strong> " + errors);
        return;
    }
    setupWord();
}

function setupWord() {
    var word_entry = data[cur_line].words[cur_word];
    var word = word_entry.word;
    var strokes = wordStrokes(word);
    var t_strokes = mapFilter(strokes, filterDifficulty);
    if (!t_strokes.length) {
        return nextWord();
    }
    function strokeCompare(a,b) {
        return a.split("/").length - b.split("/").length;
    }
    function mungeStrokes(strokes) {
        return uniq(strokes).sort(strokeCompare).join(",");
    }
    currentDrillItem = {
        "Text": word,
        "Value": mungeStrokes(t_strokes),
    }
    paintWord(word_entry);
    word_entry.elem.addClass("current");
}

function paintWord(word_entry) {
    var elem = word_entry.elem;
    elem.removeClass();
    if (!word_entry.recognized) {
        elem.addClass("nostroke");
    } else if (word_entry.status == S_DONE) {
        elem.addClass("done");
    } else if (word_entry.status == S_INCORRECT) {
        elem.addClass("incorrect");
    }
    // TODO: Add other colors which "hint" that the word is funny, e.g. if it is a brief
}

// ----------------------------------------------------------------------------
// Utility functions

function mapFilter(xs, f) {
    return xs.map(f).filter(function(x) {return x});
}

// Given list a of primitive items, returns it with duplicates removed.
function uniq(a) {
    var seen = {};
    return a.filter(function(item) {
        return seen.hasOwnProperty(item) ? false : (seen[item] = true);
    });
}

// Given to steno strokes, picks the 'better' one. We base this
// mostly on stroke size.
// TODO: have an expert look at this!
function take_best(s1, s2) {
    if (!s1) return s2;
    if (/\d/.test(s1)) { return s2; }
    if (/\d/.test(s2)) { return s1; }
    var l1 = s1.split("/").length;
    var l2 = s2.split("/").length;
    if (l1 < l2) { return s1; }
    else if (l2 < l1) { return s2; }
    // TODO: This doesn't make sense if we're not vowelizing
    if (s1.indexOf('*') == -1 && s2.indexOf('*') != -1) { return s1; }
    if (s2.indexOf('*') == -1 && s1.indexOf('*') != -1) { return s2; }
    if (s1.length < s2.length) { return s1; }
    if (s2.length < s1.length) { return s2; }
    return s1;
}

// ----------------------------------------------------------------------------
// QWERTY Steno support code

// Some of this code is pure, some relies on global state.
// Here are the variable declarations of the global state relied upon:

function showAnswerPrompt(steno) {
    streak = 0;
    misstrokes++;
    var cands = currentDrillItem.
        Value.
        split(",").
        filter(function(v){return v.indexOf(answerGivenSoFar) == 0}).
        map(function(v) {return v.substring(answerGivenSoFar.length)});
    // PROBLEM: want to figure out what LIKELY candidate was
    addSample(steno, cands);
    if (cur_mode == "speed") {
        nextWord(true);
    }
    $("#prompt").text(bestStroke(cands) + ", you did " + steno);
}
function setStenoKeyboardPressedKeys() {}
function clearStenoKeyboardPressed() {}
function hideAnswerPrompt() {}
function showWpm() {}
function setNextDrillItem() {
    streak++;
    if (streak > best_streak) best_streak = streak;
    nextWord();
}
function possibleAnswerClick() {
}
function showDrillItem() {}
// Here is the library code.

var currentTdAnswer = 0;
var itemsAnswered = 0;
var keysUp = [], keysDown = [];
var currentDrillItem;
var answerGivenSoFar = "";
var currentStroke = 1;

function correctAnswer(answer) {
    if (jQuery('#chkPlainTextInput').is(':checked')) {

        // Plain text mode
        var text = currentDrillItem.Text;

        if (text.toLowerCase() == answer.toLowerCase()) {

            return 0;
        }
    }
    else {
        // Steno mode
        var correctAnswersString = currentDrillItem.Value;

        var correctAnswersArray = correctAnswersString.split(",");

        for (var i = 0; i < correctAnswersArray.length; i++) {

            // If this possible answer starts with the same strokes as the user has given
            if (correctAnswersArray[i].indexOf(answerGivenSoFar) == 0) {

                var strokes = correctAnswersArray[i].split("/");

                var correctStroke = strokes[currentStroke - 1];

                if (answer == correctStroke) {

                    // Correct stroke
                    answerGivenSoFar += answer + "/"

                    var strokesRemaining = strokes.length - currentStroke;

                    return strokesRemaining;
                }
            }
        }
    }

    // Not a correct stroke
    return -1;
}

function getMiddleLettersFromSteno(steno) {
    var index = steno.indexOf("-");

    if (index >= 0) {
        // no vowels
        return "";
    }
    var r = "";

    if (steno.indexOf("A") >= 0) {
        r += "A";
    }

    if (steno.indexOf("O") >= 0) {
        r += "O";
    }

    if (steno.indexOf("*") >= 0) {
        r += "*";
    }

    if (steno.indexOf("E") >= 0) {
        r += "E";
    }

    if (steno.indexOf("U") >= 0) {
        r += "U";
    }
    return r;
}

function getLeftLettersFromSteno(steno) {
    
    var index = steno.indexOf("-");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("A");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("O");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("*");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    index = steno.indexOf("E");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }
    
    index = steno.indexOf("U");

    if (index >= 0) {
        
        // Found
        return steno.substring(0, index);
    }

    return steno;
}

function getRightLettersFromSteno(steno) {
    
    var index = steno.indexOf("-");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("U");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("E");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("*");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("O");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    index = steno.indexOf("A");

    if (index >= 0) {
        
        // Found
        return steno.substring(index + 1);
    }

    return "";
}

function clearKeys() {
    
    keysDown = [];
    keysUp = [];
}

function addKeyDown(letter) {

    if (letter != null) {

        if (jQuery.inArray(letter, keysDown) == -1) {

            keysDown.push(letter);

            setStenoKeyboardPressedKeys(keysDown);
        }
    }
}

function addKeyUp(letter) {

    if (letter != null) {

        if (jQuery.inArray(letter, keysUp) == -1) {

            keysUp.push(letter);
        }
    }
}

function getStenoFromLetterArray(letters) {

    var leftLetters = [];
    var rightLetters = [];
    var middleLetters = [];

    for (var i = 0; i < letters.length; i++) {

        var singleLetter = letters[i];

        var indexOfDash = singleLetter.indexOf("-");

        if (indexOfDash == 0) {

            // Key is on the right
            rightLetters.push(singleLetter[1]);
        }
        else if (indexOfDash == 1) {

            // Key is on the left
            leftLetters.push(singleLetter[0]);
        }
        else if (singleLetter == '#') {

            // Number Bar
            leftLetters.push(singleLetter);
        }
        else {
            // Middle key
            middleLetters.push(singleLetter);
        }
    }

    if (middleLetters.length == 0 && rightLetters.length > 0) {

        middleLetters.push("-");
    }

    var leftString = "";
    var rightString = "";
    var middleString = "";

    leftString = orderLeftStenoLetters(leftLetters);
    rightString = orderRightStenoLetters(rightLetters);
    middleString = orderMiddleStenoLetters(middleLetters);

    return leftString + middleString + rightString;
}

function orderLeftStenoLetters(leftLetters) {

    var result = "";

    result += getLetterFromArray("#", leftLetters);
    result += getLetterFromArray("S", leftLetters);
    result += getLetterFromArray("T", leftLetters);
    result += getLetterFromArray("K", leftLetters);
    result += getLetterFromArray("P", leftLetters);
    result += getLetterFromArray("W", leftLetters);
    result += getLetterFromArray("H", leftLetters);
    result += getLetterFromArray("R", leftLetters);

    return result;
}

function orderRightStenoLetters(rightLetters) {

    var result = "";

    result += getLetterFromArray("F", rightLetters);
    result += getLetterFromArray("R", rightLetters);
    result += getLetterFromArray("P", rightLetters);
    result += getLetterFromArray("B", rightLetters);
    result += getLetterFromArray("L", rightLetters);
    result += getLetterFromArray("G", rightLetters);
    result += getLetterFromArray("T", rightLetters);
    result += getLetterFromArray("S", rightLetters);
    result += getLetterFromArray("D", rightLetters);
    result += getLetterFromArray("Z", rightLetters);

    return result;
}

function orderMiddleStenoLetters(middleLetters) {

    var result = "";

    result += getLetterFromArray("A", middleLetters);
    result += getLetterFromArray("O", middleLetters);
    result += getLetterFromArray("*", middleLetters);
    result += getLetterFromArray("E", middleLetters);
    result += getLetterFromArray("U", middleLetters);
    result += getLetterFromArray("-", middleLetters);

    return result;
}

function getLetterFromArray(singleLetter, letterArray) {

    var result = "";

    if (jQuery.inArray(singleLetter, letterArray) > -1) {

        result += singleLetter;
    }

    return result;
}

function getStenoLetter(keyCode) {

    var result = null;

    if (keyCode == 65 || keyCode == 81) {

        result = "S-";
    }
    else if (keyCode == 87) {

        result = "T-";
    }
    else if (keyCode == 83) {

        result = "K-";
    }
    else if (keyCode == 69) {

        result = "P-";
    }
    else if (keyCode == 68) {

        result = "W-";
    }
    else if (keyCode == 82) {

        result = "H-";
    }
    else if (keyCode == 70) {

        result = "R-";
    }
    else if (keyCode == 84 || keyCode == 89 || keyCode == 71 || keyCode == 72) {

        result = "*";
    }
    else if (keyCode == 67) {

        result = "A";
    }
    else if (keyCode == 86) {

        result = "O";
    }
    else if (keyCode == 78) {

        result = "E";
    }
    else if (keyCode == 77) {

        result = "U";
    }
    else if (keyCode == 85) {

        result = "-F";
    }
    else if (keyCode == 74) {

        result = "-R";
    }
    else if (keyCode == 73) {

        result = "-P";
    }
    else if (keyCode == 75) {

        result = "-B";
    }
    else if (keyCode == 79) {

        result = "-L";
    }
    else if (keyCode == 76) {

        result = "-G";
    }
    else if (keyCode == 80) {

        result = "-T";
    }
    else if (keyCode == 186 || keyCode == 59) {

        result = "-S";
    }
    else if (keyCode == 219) {

        result = "-D";
    }
    else if (keyCode == 192 || keyCode == 222) {

        result = "-Z";
    }
    else if (keyCode >= 48 && keyCode <= 57) {

        result = "#";
    }
    else if (keyCode == 189) {

        result = "#";
    }

    return result;
}

function keyDown(event) {

    if (jQuery('#chkPlainTextInput').is(':checked')) {
        
        // Plain text mode
    }
    else {
        // Steno mode
        event.preventDefault();

        addKeyDown(getStenoLetter(event.keyCode));
    }
}

function keyUp(event) {

    if (jQuery('#chkPlainTextInput').is(':checked')) {

        // Plain text mode
        var text = jQuery('#txtInput').val();

        text = jQuery.trim(text);

        var remainingStrokes = correctAnswer(text);

        if (remainingStrokes == 0) {

            // Correct
            // Entire answer complete, no more remaining strokes
            itemsAnswered++;

            hideAnswerPrompt();

            showWpm();

            setNextDrillItem();

            showDrillItem();

            jQuery('#txtInput').val('');
        }
    }
    else {
        event.preventDefault();

        addKeyUp(getStenoLetter(event.keyCode));

        if (keysUp.length == keysDown.length) {

            // All keys up
            clearStenoKeyboardPressed();

            var steno = getStenoFromLetterArray(keysDown);

            if (steno != "") {

                if (steno != "*") {

                    var remainingStrokes = correctAnswer(steno);

                    if (remainingStrokes == 0) {

                        // Correct stroke
                        // Entire answer complete, no more remaining strokes
                        itemsAnswered++;

                        hideAnswerPrompt();

                        showWpm();

                        setNextDrillItem();

                        addSample(steno, [steno]); // XXX NEW XXX

                        showDrillItem();
                    }
                    else if (remainingStrokes > 0) {

                        // Correct stroke
                        // There are more strokes remaining
                        currentStroke++;

                        jQuery('#txtInput').val(answerGivenSoFar);

                        possibleAnswerClick(currentTdAnswer + 1);
                    }
                    else {
                        // Incorrect stroke
                        showAnswerPrompt(steno);
                    }
                }
                else {
                    // Asterisk key
                    // Delete last stroke
                    if (answerGivenSoFar.length > 0) {

                        currentStroke--;

                        var answerSoFarWithoutSlash = answerGivenSoFar.substring(answerGivenSoFar.length - 1, 1);

                        var indexOfLastSlash = answerSoFarWithoutSlash.lastIndexOf("/");

                        if (indexOfLastSlash < 0) {
                            answerGivenSoFar = "";
                        }
                        else {
                            answerGivenSoFar = answerSoFarWithoutSlash.substring(0, indexOfLastSlash);
                        }

                        jQuery('#txtInput').val(answerGivenSoFar);

                        possibleAnswerClick(currentTdAnswer + 1);
                    } else {
                        if (cur_mode == "speed") {
                            prevWord(); // XXX NEW XXX
                        }
                    }
                }
            }

            clearKeys();
        }
    }
}

</script>
</body>
</html>
